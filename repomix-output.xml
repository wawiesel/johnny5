This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/
  rules/
    important.mdc
.github/
  workflows/
    ci.yml
examples/
  01-one_page/
    01-one_page.pdf
    fixup.py
    README.md
  02-split_table/
    02-split_table.pdf
    README.md
scripts/
  pre-commit-hook
src/
  johnny5/
    fixups/
      example_fixup.py
    utils/
      __init__.py
      density.py
      fixup_context.py
      margins.py
    web/
      static/
        app.css
        app.js
        density-charts.js
      __init__.py
    __init__.py
    __main__.py
    cli.py
    decomposer.py
    qmd_checker.py
    recomposer.py
    server.py
    watcher.py
tests/
  e2e/
    controls_zindex.spec.js
    origin_axes.spec.js
    page_grid.spec.js
    ruler_sync.spec.js
    zoom_pan_sync.spec.js
  fixtures/
    __init__.py
  test_basic.py
  test_density.py
.editorconfig
.gitignore
.pre-commit-config.yaml
CODEOWNERS
CONTRIBUTING.md
DENSITY_FEATURES.md
DESIGN.md
LICENSE
playwright.config.js
pyproject.toml
README.md
SPEC.md
TODO.md
wireframe.png
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/e2e/controls_zindex.spec.js">
// Ensures zoom controls are always on top of overlays/grid
const { test, expect } = require('@playwright/test');

test('zoom controls are always the top interactive layer', async ({ page }) => {
  await page.goto('http://127.0.0.1:5173/');
  await page.waitForSelector('.pdf-controls-overlay');
  await page.waitForSelector('#pdf-grid');

  const controls = page.locator('.pdf-controls-overlay');
  const btn = controls.locator('#zoom-in');
  await expect(btn).toBeVisible();

  // Try to click through; should succeed even if overlays exist beneath
  await btn.click();

  // Validate scale changed
  const level = await page.locator('#zoom-level').innerText();
  expect(level).not.toBe('100%');
});
</file>

<file path="tests/e2e/origin_axes.spec.js">
// Verifies one X and one Y axis per page pass exactly through the origin
const { test, expect } = require('@playwright/test');

test('per-page axes pass exactly through the origin', async ({ page }) => {
  await page.goto('http://127.0.0.1:5173/');

  await page.waitForSelector('#pdf-grid');

  const pageCount = await page.locator('.pdf-page-wrapper').count();
  expect(pageCount).toBeGreaterThan(0);

  for (let i = 0; i < pageCount; i++) {
    const wrapper = page.locator('.pdf-page-wrapper').nth(i);
    const origin = wrapper.locator('.origin-marker');
    await expect(origin).toBeVisible();

    const originRect = await origin.boundingBox();
    const centerX = originRect.x + originRect.width / 2;
    const centerY = originRect.y + originRect.height / 2;

    const passesThrough = await page.evaluate(({ x, y }) => {
      const canvas = document.getElementById('pdf-grid');
      const rect = canvas.getBoundingClientRect();
      const ctx = canvas.getContext('2d');
      const cx = Math.round(x - rect.left);
      const cy = Math.round(y - rect.top);

      function isRed(R, G, B, A) { return R > 180 && G < 70 && B < 70 && A > 0; }

      // Check a small cross around center
      let vHit = false, hHit = false;
      const v = ctx.getImageData(cx, Math.max(0, cy - 5), 1, 11).data;
      for (let i = 0; i < v.length; i += 4) { if (isRed(v[i], v[i+1], v[i+2], v[i+3])) { vHit = true; break; } }
      const h = ctx.getImageData(Math.max(0, cx - 5), cy, 11, 1).data;
      for (let i = 0; i < h.length; i += 4) { if (isRed(h[i], h[i+1], h[i+2], h[i+3])) { hHit = true; break; } }
      return vHit && hHit;
    }, { x: centerX, y: centerY });

    expect(passesThrough).toBeTruthy();
  }
});
</file>

<file path="tests/e2e/page_grid.spec.js">
// Verifies square grid per page, origin inclusion, and no cross-page bleed
const { test, expect } = require('@playwright/test');

test('grid squares per page; origin included; no cross-page bleed', async ({ page }) => {
  await page.goto('http://127.0.0.1:5173/');
  await page.waitForSelector('#pdf-grid');

  const grid = page.locator('#pdf-grid');
  const canvasBox = await grid.boundingBox();
  expect(canvasBox.width).toBeGreaterThan(0);
  expect(canvasBox.height).toBeGreaterThan(0);

  const pageCount = await page.locator('.pdf-page-wrapper').count();
  expect(pageCount).toBeGreaterThan(0);

  // For each page, ensure some grid pixels exist inside page bounds and that gaps do not show grid pixels
  for (let i = 0; i < pageCount; i++) {
    const wrapper = page.locator('.pdf-page-wrapper').nth(i);
    const wRect = await wrapper.boundingBox();

    const hasGridInside = await page.evaluate(({ top, left, width, height }) => {
      const c = document.getElementById('pdf-grid');
      const r = c.getBoundingClientRect();
      const ctx = c.getContext('2d');
      const x0 = Math.max(0, Math.round(left - r.left + 5));
      const y0 = Math.max(0, Math.round(top - r.top + height / 2));
      const w = Math.max(1, Math.min(Math.round(width - 10), Math.round(r.width - x0)));
      const data = ctx.getImageData(x0, y0, w, 1).data;
      for (let i = 0; i < data.length; i += 4) {
        const [R,G,B,A] = [data[i], data[i+1], data[i+2], data[i+3]];
        const isRed = R > 170 && G < 80 && B < 80;
        const isGray = R === G && G === B && R < 210;
        if (A > 0 && (isRed || isGray)) return true;
      }
      return false;
    }, wRect);
    expect(hasGridInside).toBeTruthy();

    // Gap region: between this page bottom and next page top (if next exists)
    if (i < pageCount - 1) {
      const nextRect = await page.locator('.pdf-page-wrapper').nth(i + 1).boundingBox();
      const gapY = Math.round((wRect.y + wRect.height + nextRect.y) / 2);
      const hasInGap = await page.evaluate((absY) => {
        const c = document.getElementById('pdf-grid');
        const r = c.getBoundingClientRect();
        const ctx = c.getContext('2d');
        const y = Math.max(0, Math.round(absY - r.top));
        const data = ctx.getImageData(0, y, Math.round(r.width), 1).data;
        for (let i = 0; i < data.length; i += 4) {
          const [R,G,B,A] = [data[i], data[i+1], data[i+2], data[i+3]];
          const isRed = R > 170 && G < 80 && B < 80;
          const isGray = R === G && G === B && R < 210;
          if (A > 0 && (isRed || isGray)) return true;
        }
        return false;
      }, gapY);
      expect(hasInGap).toBeFalsy();
    }
  }
});
</file>

<file path="tests/e2e/ruler_sync.spec.js">
// Validates left-panel ruler alignment with grid and continuous scroll sync
const { test, expect } = require('@playwright/test');

test('left ruler aligns with grid and stays in scroll lockstep', async ({ page }) => {
  await page.goto('http://127.0.0.1:5173/');
  await page.waitForSelector('#pdf-grid');
  await page.waitForSelector('#y-density canvas');

  // Helper to probe for any grid/ruler line at absolute Y
  async function hasLineAtAbsoluteY(page, absY) {
    return page.evaluate((absY) => {
      const grid = document.getElementById('pdf-grid');
      const r = grid.getBoundingClientRect();
      const ctx = grid.getContext('2d');
      const y = Math.max(0, Math.min(Math.round(absY - r.top), r.height - 1));
      const row = ctx.getImageData(0, y, r.width, 1).data;
      for (let i = 0; i < row.length; i += 4) {
        const [R,G,B,A] = [row[i], row[i+1], row[i+2], row[i+3]];
        const isGrid = (R > 170 && G < 80 && B < 80) || (R === G && G === B && R < 210);
        if (A > 0 && isGrid) return true;
      }
      return false;
    }, absY);
  }

  const scroller = page.locator('#pdf-scroller');
  const ruler = page.locator('#y-density canvas');
  const rulerBox = await ruler.boundingBox();

  // Sample a few scroll positions and verify a detected grid line also exists on the ruler at same absolute Y
  for (const ratio of [0.0, 0.33, 0.66, 1.0]) {
    const maxScroll = await page.evaluate(() => {
      const s = document.getElementById('pdf-scroller');
      return s.scrollHeight - s.clientHeight;
    });
    const target = Math.max(0, Math.round(maxScroll * ratio));
    await scroller.evaluate((el, t) => el.scrollTo(0, t), target);
    await page.waitForTimeout(50);

    // Choose a Y in the middle of the viewport
    const midAbsY = (await scroller.boundingBox()).y + (await scroller.boundingBox()).height / 2;
    const gridHas = await hasLineAtAbsoluteY(page, midAbsY);

    const rulerHas = await page.evaluate((absY) => {
      const yPanel = document.getElementById('y-density');
      const c = yPanel.querySelector('canvas');
      const rr = c.getBoundingClientRect();
      const ctx = c.getContext('2d');
      const y = Math.max(0, Math.min(Math.round(absY - rr.top), rr.height - 1));
      const row = ctx.getImageData(0, y, rr.width, 1).data;
      for (let i = 0; i < row.length; i += 4) {
        const [R,G,B,A] = [row[i], row[i+1], row[i+2], row[i+3]];
        const isLine = (R > 170 && G < 80 && B < 80) || (R === G && G === B && R < 210);
        if (A > 0 && isLine) return true;
      }
      return false;
    }, midAbsY);

    expect(gridHas).toBeTruthy();
    expect(rulerHas).toBeTruthy();
  }
});
</file>

<file path="tests/e2e/zoom_pan_sync.spec.js">
// Verifies pan and zoom synchronization across grid and left ruler
const { test, expect } = require('@playwright/test');

test('pan and zoom keep grid and ruler synchronized', async ({ page }) => {
  await page.goto('http://127.0.0.1:5173/');
  await page.waitForSelector('#pdf-grid');
  await page.waitForSelector('#y-density canvas');

  const scroller = page.locator('#pdf-scroller');

  // Record a grid line absolute Y, then pan by scrolling and ensure the same grid line shifts accordingly
  const initialY = await page.evaluate(() => {
    const g = document.getElementById('pdf-grid');
    const r = g.getBoundingClientRect();
    const ctx = g.getContext('2d');
    // scan downwards to find any grid/axis pixel row near top third
    for (let y = Math.round(r.height * 0.33); y < r.height; y += 2) {
      const data = ctx.getImageData(0, y, r.width, 1).data;
      for (let i = 0; i < data.length; i += 4) {
        const [R,G,B,A] = [data[i], data[i+1], data[i+2], data[i+3]];
        const isLine = (R > 170 && G < 80 && B < 80) || (R === G && G === B && R < 210);
        if (A > 0 && isLine) return r.top + y;
      }
    }
    return null;
  });
  expect(initialY).not.toBeNull();

  // Scroll down by 200px and ensure the ruler tracks
  await scroller.evaluate(el => el.scrollBy(0, 200));
  await page.waitForTimeout(50);

  const rulerTracks = await page.evaluate((absY) => {
    const yPanel = document.getElementById('y-density');
    const c = yPanel.querySelector('canvas');
    const rr = c.getBoundingClientRect();
    const ctx = c.getContext('2d');
    const y = Math.max(0, Math.min(Math.round(absY - rr.top), rr.height - 1));
    const row = ctx.getImageData(0, y, rr.width, 1).data;
    for (let i = 0; i < row.length; i += 4) {
      const [R,G,B,A] = [row[i], row[i+1], row[i+2], row[i+3]];
      const isLine = (R > 170 && G < 80 && B < 80) || (R === G && G === B && R < 210);
      if (A > 0 && isLine) return true;
    }
    return false;
  }, initialY + 200);
  expect(rulerTracks).toBeTruthy();

  // Zoom in and ensure grid remains per-page and axes still red at origin
  await page.locator('#zoom-in').click();
  const originAxesOK = await page.evaluate(() => {
    const wrappers = document.querySelectorAll('.pdf-page-wrapper');
    if (!wrappers.length) return false;
    for (const w of wrappers) {
      const m = w.querySelector('.origin-marker');
      if (!m) return false;
    }
    return true;
  });
  expect(originAxesOK).toBeTruthy();
});
</file>

<file path="playwright.config.js">
// Playwright configuration for Johnny5 web viewer
// Runs the FastAPI server and executes e2e tests against it
const { defineConfig } = require('@playwright/test');

module.exports = defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  timeout: 15000,
  reporter: [
    ['list'],
    ['html'],
    ['json', { outputFile: 'test-results.json' }],
  ],
  use: {
    browserName: 'chromium',
    trace: 'on-first-retry',
    headless: true,
  },
  webServer: {
    // Use the venv uvicorn if present; otherwise rely on system uvicorn
    command: './venv/bin/uvicorn src.johnny5.server:app --host 127.0.0.1 --port 5173',
    url: 'http://127.0.0.1:5173/',
    reuseExistingServer: !process.env.CI,
    timeout: 120000,
  },
});
</file>

<file path=".github/workflows/ci.yml">
name: CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install dependencies
        run: |
          pip install hatch ruff black mypy pytest
          pip install -e .
      - name: Lint
        run: |
          ruff check .
          black --check .
          mypy src/johnny5
      - name: Test
        run: pytest
</file>

<file path="examples/01-one_page/fixup.py">
"""
Simple fixup for one-page document example.

This demonstrates basic fixup processing for a straightforward document
with minimal structural issues.
"""

from typing import Dict, Any, List


def fixup(structure: Dict[str, Any]) -> Dict[str, Any]:
    """
    Apply basic fixup processing to the one-page document.

    This example shows minimal fixup needed for simple documents:
    - Correct text classifications
    - Fix basic bounding boxes
    - Ensure proper element ordering

    Args:
        structure: The raw Docling JSON structure

    Returns:
        Modified structure with basic fixups applied
    """

    # Create a copy to avoid modifying the original
    fixed_structure = structure.copy()

    # Process the single page
    for page in fixed_structure.get("pages", []):
        elements = page.get("elements", [])

        # Apply basic text element fixes
        elements = _fix_text_elements(elements)

        # Sort elements by position (top to bottom)
        elements = _sort_elements_by_position(elements)

        # Update the page with fixed elements
        page["elements"] = elements

    # Add fixup metadata
    if "metadata" not in fixed_structure:
        fixed_structure["metadata"] = {}

    fixed_structure["metadata"]["fixup_applied"] = True
    fixed_structure["metadata"]["fixup_module"] = "examples.01_one_page.fixup"
    fixed_structure["metadata"]["fixup_type"] = "basic"

    return fixed_structure


def _fix_text_elements(elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Apply basic fixes to text elements."""

    fixed_elements = []

    for element in elements:
        if element.get("type") == "text":
            # Fix text classification based on content
            element = _classify_text_element(element)

            # Fix bounding boxes
            element = _fix_basic_bbox(element)

        fixed_elements.append(element)

    return fixed_elements


def _classify_text_element(element: Dict[str, Any]) -> Dict[str, Any]:
    """Classify text elements based on content patterns."""

    content = element.get("content", "")
    if isinstance(content, str):
        content_lower = content.lower().strip()

        # Classify based on content patterns
        if any(keyword in content_lower for keyword in ["simple document", "test"]):
            element["classification"] = "title"
        elif any(
            keyword in content_lower
            for keyword in [
                "basic text",
                "list processing",
                "numbered lists",
                "code and technical",
                "conclusion",
            ]
        ):
            element["classification"] = "section_header"
        elif content_lower.startswith(("•", "-", "*", "1.", "2.", "3.")):
            element["classification"] = "list_item"
        elif content_lower.startswith(("def ", "    ", "return ")):
            element["classification"] = "code"
        else:
            element["classification"] = "paragraph"

    return element


def _fix_basic_bbox(element: Dict[str, Any]) -> Dict[str, Any]:
    """Fix basic bounding box issues."""

    bbox = element.get("bbox", [])
    if len(bbox) == 4:
        x1, y1, x2, y2 = bbox

        # Ensure bounding box is valid
        if x2 <= x1 or y2 <= y1:
            # Fix invalid bounding boxes with reasonable defaults
            element["bbox"] = [x1, y1, x1 + 200, y1 + 20]
        elif (x2 - x1) < 10 or (y2 - y1) < 5:
            # Fix tiny bounding boxes
            element["bbox"] = [x1, y1, x1 + 100, y1 + 15]

    return element


def _sort_elements_by_position(elements: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Sort elements by their vertical position (top to bottom)."""

    def get_y_position(element):
        bbox = element.get("bbox", [])
        if len(bbox) >= 2:
            return bbox[1]  # y1 coordinate
        return 0

    return sorted(elements, key=get_y_position, reverse=True)  # Reverse for top-to-bottom
</file>

<file path="examples/01-one_page/README.md">
# 01-one_page Example

## What This Tests

This example tests Johnny5's basic parsing capabilities for simple documents:

- **Text elements**: Headers, paragraphs, and basic formatting
- **Formatting**: Bold, italic, and underlined text
- **Lists**: Both bullet points and numbered lists
- **Code blocks**: Simple code snippets
- **Structure**: Basic document hierarchy without complex layouts

## How to Regenerate

To regenerate the PDF from the source QMD file:

```bash
jny5 check 01-one_page.qmd
jny5 to-pdf 01-one_page.qmd
```

This will create `01-one_page.pdf` using Quarto to render the QMD source.

## File Contents

- `01-one_page.qmd` - Source Quarto Markdown file
- `01-one_page.pdf` - Generated PDF for testing
- `README.md` - This file
</file>

<file path="examples/02-split_table/README.md">
# 02-split_table Example

## What This Tests

This example tests Johnny5's table parsing capabilities, particularly:

- **Page breaks in tables**: A long table (50+ rows) that splits across multiple pages
- **Table structure**: Consistent formatting and proper cell boundaries
- **Different table sizes**: Both long and short tables for comparison
- **Table parsing challenges**: How Johnny5 handles tables that span page boundaries

## How to Regenerate

To regenerate the PDF from the source QMD file:

```bash
jny5 check 02-split_table.qmd
jny5 to-pdf 02-split_table.qmd
```

This will create `02-split_table.pdf` using Quarto to render the QMD source.

## File Contents

- `02-split_table.qmd` - Source Quarto Markdown file with long and short tables
- `02-split_table.pdf` - Generated PDF for testing
- `README.md` - This file
</file>

<file path="src/johnny5/web/__init__.py">
"""Johnny5 web package"""

__all__ = []
</file>

<file path="src/johnny5/__init__.py">
"""Johnny5 - Document decomposition and recomposition framework"""

__version__ = "0.1.0"
__author__ = "William Wieselquist"

from .cli import main
from .decomposer import run_decompose
from .recomposer import json_to_qmd, json_to_html
from .server import run_web

__all__ = ["main", "run_decompose", "json_to_qmd", "json_to_html", "run_web"]
</file>

<file path="src/johnny5/__main__.py">
"""Johnny5 main entrypoint for python -m johnny5"""

from .cli import main

if __name__ == "__main__":
    main()
</file>

<file path="src/johnny5/qmd_checker.py">
"""
QMD Quality Checker for Johnny5.

This module provides quality checks for Quarto Markdown files,
including table alignment validation and other formatting checks.
"""

import re
from pathlib import Path
from typing import List, Dict, Any


class QMDChecker:
    """Quality checker for QMD files."""

    def __init__(self, file_path: Path):
        self.file_path = file_path
        self.content = self._read_file()
        self.issues: List[Dict[str, Any]] = []

    def _read_file(self) -> str:
        """Read the QMD file content."""
        try:
            with open(self.file_path, "r", encoding="utf-8") as f:
                return f.read()
        except Exception as e:
            self.issues.append(f"Error reading file: {e}")
            return ""

    def check_all(self) -> Dict[str, Any]:
        """Run all quality checks."""
        results = {"file": str(self.file_path), "issues": [], "checks": {}}

        # Run individual checks
        results["checks"]["table_alignment"] = self.check_table_alignment()
        results["checks"]["yaml_frontmatter"] = self.check_yaml_frontmatter()
        results["checks"]["markdown_syntax"] = self.check_markdown_syntax()

        # Collect all issues
        for check_name, check_result in results["checks"].items():
            if check_result["issues"]:
                results["issues"].extend(check_result["issues"])

        return results

    def check_table_alignment(self) -> Dict[str, Any]:
        """Check if tables have properly aligned columns."""
        issues: List[Dict[str, Any]] = []
        tables_found = 0
        tables_aligned = 0

        lines: List[str] = self.content.split("\n")
        in_table = False
        table_lines = []
        table_start_line = 0

        for i, line in enumerate(lines, 1):
            # Check if this line is a table row
            if self._is_table_row(line):
                if not in_table:
                    # Start new table
                    in_table = True
                    table_lines = [line]
                    table_start_line = i
                else:
                    # Continue existing table
                    table_lines.append(line)
            elif in_table:
                # End of table (empty line or non-table content)
                if len(table_lines) >= 2:  # Only check tables with at least header + 1 row
                    alignment_result = self._check_table_alignment(table_lines, table_start_line)
                    tables_found += 1
                    if alignment_result["aligned"]:
                        tables_aligned += 1
                    else:
                        issues.extend(alignment_result["issues"])

                in_table = False
                table_lines = []

        # Check final table if file ends with one
        if in_table and table_lines and len(table_lines) >= 2:
            alignment_result = self._check_table_alignment(table_lines, table_start_line)
            tables_found += 1
            if alignment_result["aligned"]:
                tables_aligned += 1
            else:
                issues.extend(alignment_result["issues"])

        return {
            "issues": issues,
            "tables_found": tables_found,
            "tables_aligned": tables_aligned,
            "all_aligned": tables_found == tables_aligned,
        }

    def _is_table_header(self, line: str) -> bool:
        """Check if line is a table header."""
        return bool(re.match(r"^\s*\|.*\|.*\|", line.strip()))

    def _is_table_row(self, line: str) -> bool:
        """Check if line is a table row."""
        return bool(re.match(r"^\s*\|.*\|", line.strip()))

    def _check_table_alignment(self, table_lines: List[str], start_line: int) -> Dict[str, Any]:
        """Check alignment of a specific table."""
        if len(table_lines) < 2:
            return {"aligned": True, "issues": []}

        issues = []

        # Find pipe positions in first line
        first_line = table_lines[0]
        pipe_positions = [m.start() for m in re.finditer(r"\|", first_line)]

        if len(pipe_positions) < 2:
            return {"aligned": True, "issues": []}

        # Check each subsequent line
        for i, line in enumerate(table_lines[1:], 1):
            line_pipe_positions = [m.start() for m in re.finditer(r"\|", line)]

            # Check if pipe positions match
            if len(line_pipe_positions) != len(pipe_positions):
                issues.append(f"Line {start_line + i}: Table has inconsistent number of columns")
                continue

            # Check if pipes are aligned
            for j, (expected_pos, actual_pos) in enumerate(
                zip(pipe_positions, line_pipe_positions)
            ):
                if expected_pos != actual_pos:
                    issues.append(
                        f"Line {start_line + i}, column {j + 1}: Pipe misaligned "
                        f"(expected position {expected_pos}, found at {actual_pos})"
                    )

        return {"aligned": len(issues) == 0, "issues": issues}

    def check_yaml_frontmatter(self) -> Dict[str, Any]:
        """Check YAML frontmatter formatting."""
        issues = []

        if not self.content.startswith("---"):
            issues.append("Missing YAML frontmatter")
            return {"issues": issues, "has_frontmatter": False}

        # Find end of frontmatter
        lines = self.content.split("\n")
        frontmatter_end = -1

        for i, line in enumerate(lines[1:], 1):
            if line.strip() == "---":
                frontmatter_end = i
                break

        if frontmatter_end == -1:
            issues.append("YAML frontmatter not properly closed")
            return {"issues": issues, "has_frontmatter": False}

        # Check frontmatter content
        frontmatter_lines = lines[1:frontmatter_end]

        # Check for common required fields
        frontmatter_text = "\n".join(frontmatter_lines)

        if "title:" not in frontmatter_text:
            issues.append("Missing 'title' in frontmatter")

        if "format:" not in frontmatter_text:
            issues.append("Missing 'format' in frontmatter")

        return {
            "issues": issues,
            "has_frontmatter": True,
            "frontmatter_lines": len(frontmatter_lines),
        }

    def check_markdown_syntax(self) -> Dict[str, Any]:
        """Check basic markdown syntax issues."""
        issues = []

        lines = self.content.split("\n")

        # Check for common issues
        for i, line in enumerate(lines, 1):
            # Check for trailing whitespace
            if line.endswith(" ") or line.endswith("\t"):
                issues.append(f"Line {i}: Trailing whitespace")

            # Check for inconsistent heading levels
            if re.match(r"^#{4,}", line.strip()):
                issues.append(f"Line {i}: Heading level 4+ (consider restructuring)")

        return {"issues": issues, "total_lines": len(lines)}


def check_qmd_file(file_path: Path) -> Dict[str, Any]:
    """Check a QMD file for quality issues."""
    checker = QMDChecker(file_path)
    return checker.check_all()


def format_check_results(results: Dict[str, Any]) -> str:
    """Format check results for display."""
    output = []

    output.append(f"QMD Quality Check: {results['file']}")
    output.append("=" * 50)

    if not results["issues"]:
        output.append("✅ All checks passed!")
        return "\n".join(output)

    # Show summary
    output.append(f"❌ Found {len(results['issues'])} issues:")
    output.append("")

    # Group issues by check type
    for check_name, check_result in results["checks"].items():
        if check_result.get("issues"):
            output.append(f"{check_name.replace('_', ' ').title()}:")
            for issue in check_result["issues"]:
                output.append(f"  • {issue}")
            output.append("")

    # Show all issues
    if results["issues"]:
        output.append("All Issues:")
        for issue in results["issues"]:
            output.append(f"  • {issue}")

    return "\n".join(output)
</file>

<file path="src/johnny5/recomposer.py">
"""Johnny5 Recomposer - JSON to QMD/HTML conversion"""

from pathlib import Path
from typing import Dict, Any, Optional
import json


def json_to_qmd(json_path: Path, output_path: Optional[Path] = None) -> Path:
    """
    Convert Johnny5 JSON to Quarto Markdown (.qmd)

    Args:
        json_path: Path to the Johnny5 JSON file
        output_path: Optional output path (defaults to json_path with .qmd extension)

    Returns:
        Path to the generated QMD file
    """
    if output_path is None:
        output_path = json_path.with_suffix(".qmd")

    print(f"📝 Converting {json_path} to QMD")

    # Load JSON data
    with open(json_path, "r") as f:
        data = json.load(f)

    # TODO: Implement JSON to QMD conversion
    # 1. Parse structure from JSON
    # 2. Convert tables to markdown
    # 3. Handle figures and images
    # 4. Generate QMD with proper formatting

    # Placeholder QMD content
    qmd_content = f"""---
title: "Document from {data['metadata']['source_pdf']}"
format: html
---

# Document Analysis

This document was processed using Johnny5 with:
- Layout model: {data['metadata']['layout_model']}
- OCR enabled: {data['metadata']['ocr_enabled']}
- JSON DPI: {data['metadata']['json_dpi']}

## Structure

- Tables: {len(data['structure']['tables'])}
- Figures: {len(data['structure']['figures'])}
- Text blocks: {len(data['structure']['text_blocks'])}

<!-- TODO: Implement full QMD generation -->
"""

    with open(output_path, "w") as f:
        f.write(qmd_content)

    print(f"✅ QMD saved to: {output_path}")
    return output_path


def json_to_html(json_path: Path, output_path: Optional[Path] = None) -> Path:
    """
    Convert Johnny5 JSON to HTML

    Args:
        json_path: Path to the Johnny5 JSON file
        output_path: Optional output path (defaults to json_path with .html extension)

    Returns:
        Path to the generated HTML file
    """
    if output_path is None:
        output_path = json_path.with_suffix(".html")

    print(f"🌐 Converting {json_path} to HTML")

    # Load JSON data
    with open(json_path, "r") as f:
        data = json.load(f)

    # TODO: Implement JSON to HTML conversion
    # 1. Generate HTML structure
    # 2. Style tables and figures
    # 3. Add interactive elements
    # 4. Include PDF.js integration

    # Placeholder HTML content
    html_content = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Johnny5 Document Viewer</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .metadata {{ background: #f5f5f5; padding: 15px; border-radius: 5px; }}
        .structure {{ margin-top: 20px; }}
    </style>
</head>
<body>
    <h1>Document Analysis</h1>
    
    <div class="metadata">
        <h2>Processing Information</h2>
        <p><strong>Source PDF:</strong> {data['metadata']['source_pdf']}</p>
        <p><strong>Layout Model:</strong> {data['metadata']['layout_model']}</p>
        <p><strong>OCR Enabled:</strong> {data['metadata']['ocr_enabled']}</p>
        <p><strong>JSON DPI:</strong> {data['metadata']['json_dpi']}</p>
    </div>
    
    <div class="structure">
        <h2>Document Structure</h2>
        <ul>
            <li>Tables: {len(data['structure']['tables'])}</li>
            <li>Figures: {len(data['structure']['figures'])}</li>
            <li>Text blocks: {len(data['structure']['text_blocks'])}</li>
        </ul>
    </div>
    
    <!-- TODO: Implement full HTML generation -->
</body>
</html>"""

    with open(output_path, "w") as f:
        f.write(html_content)

    print(f"✅ HTML saved to: {output_path}")
    return output_path


def process_structure(data: Dict[str, Any]) -> Dict[str, Any]:
    """Process and normalize document structure from JSON"""
    # TODO: Implement structure processing
    return data
</file>

<file path="tests/test_density.py">
"""Tests for density calculation utilities

This module tests the density calculation functions in johnny5.utils.density.
"""

from johnny5.utils.density import (
    compute_horizontal_density,
    compute_vertical_density,
    compute_density_arrays,
    calculate_document_resolution,
)


def test_compute_horizontal_density_empty() -> None:
    """Test horizontal density with no elements."""
    result = compute_horizontal_density([])
    assert result == {"left": 0.0, "center": 0.0, "right": 0.0}


def test_compute_horizontal_density_left() -> None:
    """Test horizontal density with elements on the left."""
    elements = [
        {"bbox": [0, 0, 100, 50]},
        {"bbox": [10, 10, 80, 40]},
        {"bbox": [50, 20, 150, 70]},
    ]
    # Assuming page width is 612 (standard letter width in points)
    result = compute_horizontal_density(elements)
    assert result["left"] > 0


def test_compute_vertical_density_empty() -> None:
    """Test vertical density with no elements."""
    result = compute_vertical_density([])
    assert result == {"top": 0.0, "middle": 0.0, "bottom": 0.0}


def test_compute_vertical_density_top() -> None:
    """Test vertical density with elements at the top."""
    elements = [
        {"bbox": [0, 0, 100, 50]},
        {"bbox": [10, 10, 80, 40]},
        {"bbox": [50, 20, 150, 70]},
    ]
    # Assuming page height is 792 (standard letter height in points)
    result = compute_vertical_density(elements)
    assert result["top"] > 0


def test_compute_density_arrays_empty() -> None:
    """Test density arrays with no elements."""
    x_array, y_array = compute_density_arrays([], 612.0, 792.0, resolution=50)
    # Returns empty arrays when no elements
    assert len(x_array) == 0
    assert len(y_array) == 0


def test_compute_density_arrays_basic() -> None:
    """Test density arrays with simple elements."""
    elements = [
        {"bbox": [0, 0, 100, 50]},
        {"bbox": [200, 50, 400, 100]},
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=50)

    assert len(x_array) == 50
    assert len(y_array) == 50
    assert sum(x_array) > 0
    assert sum(y_array) > 0


def test_compute_density_arrays_full_page() -> None:
    """Test density arrays with element spanning full page."""
    elements = [
        {"bbox": [0, 0, 612, 792]},  # Full page element
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=50)

    # Each bin should have at least 1 count
    assert all(v >= 1 for v in x_array)
    assert all(v >= 1 for v in y_array)


def test_compute_density_arrays_auto_resolution() -> None:
    """Test density arrays with auto-calculated resolution."""
    elements = [
        {"bbox": [50, 50, 150, 100]},
        {"bbox": [200, 200, 300, 250]},
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=72)

    # Resolution should be calculated
    assert len(x_array) > 0
    assert len(y_array) > 0
    assert len(x_array) <= 200  # Should respect reasonable bounds


def test_calculate_document_resolution_empty() -> None:
    """Test resolution calculation with no pages."""
    pages: list[dict[str, list[dict[str, list[float]]]]] = []
    resolution = calculate_document_resolution(pages)
    assert resolution == 50  # Default


def test_calculate_document_resolution_basic() -> None:
    """Test resolution calculation with sample pages."""
    pages = [
        {
            "elements": [
                {"bbox": [0, 0, 100, 50]},
                {"bbox": [50, 100, 150, 150]},
            ]
        },
        {
            "elements": [
                {"bbox": [0, 0, 200, 100]},
            ]
        },
    ]
    resolution = calculate_document_resolution(pages)
    assert 10 <= resolution <= 200  # Should be within reasonable bounds


def test_calculate_document_resolution_with_empty_elements() -> None:
    """Test resolution calculation when some elements have invalid bboxes."""
    pages = [
        {
            "elements": [
                {"bbox": [0, 0, 100, 50]},
                {"bbox": []},  # Invalid bbox
                {"bbox": [50, 50, 50, 50]},  # Zero size
            ]
        },
    ]
    resolution = calculate_document_resolution(pages)
    assert resolution > 0


def test_density_arrays_normalization() -> None:
    """Test that density arrays properly normalize coordinates."""
    elements = [
        {"bbox": [100, 100, 200, 150]},  # In the middle region
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=100)

    # Values should be normalized to [0, 1]
    assert sum(x_array) > 0
    assert sum(y_array) > 0


def test_density_arrays_edge_cases() -> None:
    """Test density arrays with edge cases."""
    # Element at exact edges
    elements = [
        {"bbox": [0, 0, 612, 792]},  # Full page
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=50)

    # First and last bins should have values
    assert x_array[0] > 0
    assert y_array[0] > 0


def test_density_arrays_out_of_bounds() -> None:
    """Test density arrays with coordinates outside page bounds."""
    elements = [
        {"bbox": [-10, -10, 700, 800]},  # Out of bounds
    ]
    x_array, y_array = compute_density_arrays(elements, 612.0, 792.0, resolution=50)

    # Should clamp to page bounds
    assert all(v >= 0 for v in x_array)
    assert all(v >= 0 for v in y_array)


def test_compute_density_arrays_different_resolutions() -> None:
    """Test density arrays with different resolutions."""
    elements = [
        {"bbox": [50, 50, 150, 100]},
    ]

    x_array_10, y_array_10 = compute_density_arrays(elements, 612.0, 792.0, resolution=10)
    x_array_100, y_array_100 = compute_density_arrays(elements, 612.0, 792.0, resolution=100)

    assert len(x_array_10) == 10
    assert len(y_array_10) == 10
    assert len(x_array_100) == 100
    assert len(y_array_100) == 100

    # Higher resolution should have more granular data
    assert len(x_array_100) > len(x_array_10)
</file>

<file path=".editorconfig">
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true
indent_style = space
indent_size = 4

[*.{yml,yaml}]
indent_size = 2

[*.{js,ts,json}]
indent_size = 2

[*.md]
trim_trailing_whitespace = false
</file>

<file path="DENSITY_FEATURES.md">
# Density and Label Features - Implementation Summary

## Status: ✅ Enabled and Ready

The following features have been implemented for the Johnny5 web viewer:

### 1. **X/Y Density Charts**
- **X-Density Top Banners**: Horizontal bar charts showing horizontal element density
- **Y-Density Side Panels**: Vertical bar charts showing vertical element density  
- **Auto-updates**: Charts refresh when scrolling to different pages
- **Location**: Displayed in green (#9acd32) and yellow/gold (#ffd700) panels

### 2. **Bounding Box Overlays**
- **Colored Boxes**: Each PDF element is outlined with a colored bounding box
- **Color Coding**: 
  - `text`: Blue
  - `title`: Green
  - `section_header`: Orange
  - `table`: Red
  - `figure`: Purple
  - `list_item`: Cyan
  - Default: Gray
- **Interactive**: Clickable boxes with hover effects
- **Multi-page**: Works across all pages in the document

### 3. **Label Toggles**
- **Filter by Type**: Checkboxes to show/hide elements by type
- **Color Swatches**: Visual indicators showing the color for each element type
- **Controls**: "Select All" / "Deselect All" buttons
- **Dynamic**: Automatically extracts all unique element types from the document
- **Location**: Blue toggles panel (bottom left area)

## How to Use

1. Start the web viewer:
   ```bash
   jny5 view examples/02-split_table/02-split_table.pdf
   ```

2. Once the PDF loads:
   - **Density charts** appear automatically at the top and sides
   - **Bounding boxes** are overlaid on the PDF elements
   - **Label toggles** appear in the toggles panel

3. Interactive features:
   - Click bounding boxes to highlight them
   - Use label toggles to filter elements by type
   - Scroll through pages to see density charts update
   - Zoom in/out to see overlays adjust

## Technical Implementation

### Backend
- Density calculation in `src/johnny5/utils/density.py`
- Structure data returned via `/api/structure/{page}`
- Density data returned via `/api/density/{page}`

### Frontend
- Density chart rendering in `src/johnny5/web/static/app.js`
- Canvas elements in `src/johnny5/web/templates/index.html`
- Styling in `src/johnny5/web/static/app.css`

### Tests
- Backend density calculation tests: `tests/test_density.py`
- All 15 tests passing ✅

## Requirements

For the features to display:
1. PDF must be disassembled first to generate structure data
2. Structure data must exist in `_cache/` directory
3. Web viewer must be running and have access to structure endpoints

The implementation is complete and ready to use!
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 William Wieselquist

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="scripts/pre-commit-hook">
#!/bin/bash

# Pre-commit hook to validate example README files
# This hook runs bash commands found in ```bash code blocks in example README files

set -e

echo "🔍 Running pre-commit validation for example README files..."

# Find all README.md files in examples/*/ directories
readme_files=$(find examples -name "README.md" -type f)

if [ -z "$readme_files" ]; then
    echo "ℹ️  No example README files found"
    exit 0
fi

validation_failed=false

for readme_file in $readme_files; do
    echo "📄 Validating $readme_file"
    
    # Extract bash code blocks from the README file
    bash_commands=$(grep -A 1000 '```bash' "$readme_file" | grep -B 1000 '```' | grep -v '```bash' | grep -v '```' | grep -v '^$' || true)
    
    if [ -z "$bash_commands" ]; then
        echo "  ⚠️  No bash commands found in $readme_file"
        continue
    fi
    
    # Get the directory containing the README file
    example_dir=$(dirname "$readme_file")
    
    echo "  📁 Running commands in $example_dir:"
    
    # Run each bash command in the example directory
    while IFS= read -r command; do
        if [ -n "$command" ]; then
            echo "    🔧 Running: $command"
            
            # Handle file-modifying commands specially - validate without modifying
            if [[ "$command" == *"to-pdf"* ]]; then
                echo "    🔧 Validating file-modifying command: $command"
                # Test the command in a temporary directory to avoid modifying tracked files
                temp_dir=$(mktemp -d)
                cp -r "$example_dir"/* "$temp_dir/" 2>/dev/null || true
                # Calculate the correct path to venv from the temp directory
                venv_path=$(realpath "$example_dir/../../venv/bin/activate")
                src_path=$(realpath "$example_dir/../../src")
                if (cd "$temp_dir" && source "$venv_path" && export PATH="$(dirname "$venv_path"):$PATH" && export PYTHONPATH="$src_path:$PYTHONPATH" && eval "$command" >/dev/null 2>&1); then
                    echo "    ✅ Command would succeed: $command"
                    rm -rf "$temp_dir"
                else
                    echo "    ❌ Command failed: $command"
                    rm -rf "$temp_dir"
                    validation_failed=true
                fi
                continue
            fi
            
            # Change to the example directory and run the command
            # Use the virtual environment's Python to ensure jny5 is available
            if ! (cd "$example_dir" && source ../../venv/bin/activate && export PATH="../../venv/bin:$PATH" && export PYTHONPATH="../../src:$PYTHONPATH" && eval "$command"; exit_code=$?; echo "    Exit code: $exit_code"; exit $exit_code); then
                echo "    ❌ Command failed: $command"
                validation_failed=true
            else
                echo "    ✅ Command succeeded: $command"
            fi
        fi
    done <<< "$bash_commands"
done

if [ "$validation_failed" = true ]; then
    echo ""
    echo "❌ Pre-commit validation failed!"
    echo "   Please fix the issues in the example README files before committing."
    exit 1
else
    echo ""
    echo "✅ All example README commands validated successfully!"
fi

# --- JS/CSS Linters (optional, run if available) ---
echo ""
echo "🔎 Running JS/CSS linters (if installed)"

# Detect project root (this script lives in scripts/)
ROOT_DIR=$(cd "$(dirname "$0")/.." && pwd)

# ESLint
if command -v npx >/dev/null 2>&1 && [ -f "$ROOT_DIR/.eslintrc.json" ]; then
    echo "▶ ESLint: src/johnny5/web/static/**/*.js"
    if ! (cd "$ROOT_DIR" && npx --yes eslint "src/johnny5/web/static/**/*.js"); then
        echo "❌ ESLint failed"
        exit 1
    else
        echo "✅ ESLint passed"
    fi
else
    echo "ℹ️  ESLint not configured (skipping). Add .eslintrc.json and devDependencies to enable."
fi

# Stylelint
if command -v npx >/dev/null 2>&1 && [ -f "$ROOT_DIR/.stylelintrc.json" ]; then
    echo "▶ Stylelint: src/johnny5/web/static/**/*.css"
    if ! (cd "$ROOT_DIR" && npx --yes stylelint "src/johnny5/web/static/**/*.css"); then
        echo "❌ Stylelint failed"
        exit 1
    else
        echo "✅ Stylelint passed"
    fi
else
    echo "ℹ️  Stylelint not configured (skipping). Add .stylelintrc.json and devDependencies to enable."
fi

exit 0
</file>

<file path="src/johnny5/utils/__init__.py">
"""Johnny5 utilities package"""

from .density import compute_horizontal_density, compute_vertical_density, calculate_density
from .margins import analyze_page_margins, analyze_margins
from .fixup_context import FixupContext

__all__ = [
    "compute_horizontal_density",
    "compute_vertical_density",
    "calculate_density",
    "analyze_page_margins",
    "analyze_margins",
    "FixupContext",
]
</file>

<file path="src/johnny5/utils/fixup_context.py">
"""Johnny5 fixup context utilities

This module provides the FixupContext dataclass for passing context
information to fixup processing functions.
"""

import logging
from pathlib import Path
from typing import Dict, Any, List
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class FixupContext:
    """
    Context information for fixup processing.

    This dataclass contains all the information needed by fixup functions
    to process document elements according to the fixup protocol:
    - None → keep cluster
    - str → relabel cluster
    - dict → replace cluster
    - list[dict] → split cluster
    """

    pdf_path: Path
    """Path to the original PDF file"""

    pages: List[Dict[str, Any]]
    """List of processed page data with elements and metadata"""

    structure: Dict[str, List[Dict[str, Any]]]
    """High-level document structure (tables, figures, text_blocks)"""

    metadata: Dict[str, Any]
    """Document metadata including processing parameters"""

    def get_page_elements(self, page_number: int) -> List[Dict[str, Any]]:
        """
        Get elements for a specific page.

        Args:
            page_number: Page number (1-indexed)

        Returns:
            List of elements for the specified page
        """
        for page in self.pages:
            if page.get("page_number") == page_number:
                return page.get("elements", [])
        return []

    def get_elements_by_type(self, element_type: str) -> List[Dict[str, Any]]:
        """
        Get all elements of a specific type across all pages.

        Args:
            element_type: Type of elements to retrieve (e.g., "table", "text")

        Returns:
            List of elements matching the specified type
        """
        elements = []
        for page in self.pages:
            for element in page.get("elements", []):
                if element.get("type") == element_type:
                    elements.append(element)
        return elements

    def get_structure_summary(self) -> Dict[str, int]:
        """
        Get a summary of document structure.

        Returns:
            Dictionary with counts of different element types
        """
        return {
            "total_pages": len(self.pages),
            "total_tables": len(self.structure.get("tables", [])),
            "total_figures": len(self.structure.get("figures", [])),
            "total_text_blocks": len(self.structure.get("text_blocks", [])),
        }
</file>

<file path="src/johnny5/utils/margins.py">
"""Johnny5 margin analysis utilities

This module provides functions to analyze page margins and element positioning
for context-aware fixup processing.
"""

import logging
from typing import List, Dict, Any

logger = logging.getLogger(__name__)


def analyze_page_margins(elements: List[Dict[str, Any]]) -> Dict[str, float]:
    """
    Analyze page margins based on element bounding boxes.

    Args:
        elements: List of page elements with bbox coordinates

    Returns:
        Dictionary containing margin measurements
    """
    if not elements:
        return {"left": 0.0, "right": 0.0, "top": 0.0, "bottom": 0.0}

    # Extract bbox coordinates
    bboxes = [elem.get("bbox", [0, 0, 0, 0]) for elem in elements]

    # Calculate margins using percentiles
    left_margin = min(bbox[0] for bbox in bboxes) if bboxes else 0.0
    right_margin = 1.0 - max(bbox[2] for bbox in bboxes) if bboxes else 0.0
    top_margin = min(bbox[1] for bbox in bboxes) if bboxes else 0.0
    bottom_margin = 1.0 - max(bbox[3] for bbox in bboxes) if bboxes else 0.0

    return {
        "left": left_margin,
        "right": right_margin,
        "top": top_margin,
        "bottom": bottom_margin,
    }


def analyze_margins(elements: List[Dict[str, Any]]) -> Dict[str, float]:
    """
    Legacy function name for margin analysis.

    Args:
        elements: List of page elements with bbox coordinates

    Returns:
        Dictionary containing margin measurements
    """
    return analyze_page_margins(elements)
</file>

<file path="src/johnny5/cli.py">
import click
import subprocess
import sys
import warnings
import tempfile
import shutil
from pathlib import Path
from .decomposer import run_decompose
from .server import run_web
from .qmd_checker import check_qmd_file, format_check_results

# Suppress RuntimeWarning about module loading
warnings.filterwarnings("ignore", category=RuntimeWarning, module="runpy")


@click.group()
def main() -> None:
    """Johnny5 — Disassemble. Understand. Reassemble."""
    pass


@main.command()
@click.argument("pdf", type=click.Path(exists=True, path_type=Path))
@click.option("--layout-model", default="pubtables")
@click.option("--enable-ocr", is_flag=True)
@click.option("--json-dpi", default=300)
@click.option("--fixup", default="johnny5.fixups.example_fixup")
def disassemble(pdf: Path, layout_model: str, enable_ocr: bool, json_dpi: int, fixup: str) -> None:
    """Disassemble PDF -> Lossless JSON"""
    run_decompose(pdf, layout_model, enable_ocr, json_dpi, fixup)


@main.command()
@click.argument("pdf", type=click.Path(exists=True, path_type=Path))
@click.option("--port", default=8000)
@click.option("--fixup", default="johnny5.fixups.example_fixup")
def web(pdf: Path, port: int, fixup: str) -> None:
    """Launch the web viewer"""
    run_web(pdf, port, fixup)


@main.command()
@click.argument("file", type=click.Path(exists=True, path_type=Path))
def check(file: Path) -> None:
    """Check file for quality issues based on file extension (currently supports .qmd)"""
    try:
        # Check file extension and route to appropriate checker
        if file.suffix.lower() == ".qmd":
            results = check_qmd_file(file)
            formatted_output = format_check_results(results)
            print(formatted_output)

            # Exit with error code if issues found
            if results["issues"]:
                raise click.ClickException("File quality check failed")
        else:
            raise click.ClickException(
                f"Unsupported file type: {file.suffix}. Currently only .qmd files are supported."
            )

    except click.ClickException:
        raise
    except Exception as e:
        raise click.ClickException(f"Error checking file: {e}")


@main.command()
@click.argument("file", type=click.Path(exists=True, path_type=Path))
def to_pdf(file: Path) -> None:
    """Render file to PDF based on file extension (currently supports .qmd using Quarto)"""
    try:
        # Check file extension and route to appropriate renderer
        if file.suffix.lower() == ".qmd":
            # Create a temporary directory for Quarto rendering
            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                # Copy the QMD file to the temporary directory
                temp_qmd = temp_path / file.name
                shutil.copy2(file, temp_qmd)

                # Run quarto render command in the temporary directory
                cmd = ["quarto", "render", str(temp_qmd), "--to", "pdf"]

                subprocess.run(cmd, capture_output=True, text=True, check=True)

                # Copy the generated PDF back to the original directory
                temp_pdf = temp_path / f"{file.stem}.pdf"
                final_pdf = file.parent / f"{file.stem}.pdf"
                shutil.copy2(temp_pdf, final_pdf)

                # Clean up any auxiliary files that Quarto might have created in the original directory
                aux_extensions = [
                    ".aux",
                    ".log",
                    ".out",
                    ".toc",
                    ".fdb_latexmk",
                    ".fls",
                    ".synctex.gz",
                ]
                for ext in aux_extensions:
                    aux_file = file.parent / f"{file.stem}{ext}"
                    if aux_file.exists():
                        aux_file.unlink()

                print(f"✅ PDF generated: {final_pdf}")
        else:
            raise click.ClickException(
                f"Unsupported file type: {file.suffix}. Currently only .qmd files are supported."
            )

    except subprocess.CalledProcessError as e:
        print(f"❌ Error rendering file to PDF: {e}")
        print(f"Quarto output: {e.stderr}")
        sys.exit(1)
    except FileNotFoundError:
        print("❌ Quarto not found. Please install Quarto to render QMD files to PDF.")
        sys.exit(1)
</file>

<file path="tests/fixtures/__init__.py">
"""Test fixtures and utilities for Johnny5 tests"""

from pathlib import Path
from typing import Dict, Any
import json


def create_sample_pdf_json() -> Dict[str, Any]:
    """Create a sample PDF JSON structure for testing"""
    return {
        "metadata": {
            "source_pdf": "sample.pdf",
            "layout_model": "pubtables",
            "ocr_enabled": False,
            "json_dpi": 300,
            "fixup_module": "johnny5.fixups.example_fixup",
        },
        "pages": [
            {
                "page_number": 1,
                "width": 612,
                "height": 792,
                "elements": [
                    {
                        "type": "text",
                        "content": "Sample Document",
                        "bbox": [50, 50, 200, 80],
                        "style": {"font_size": 16, "font_weight": "bold"},
                    },
                    {
                        "type": "table",
                        "content": [["Header 1", "Header 2"], ["Cell 1", "Cell 2"]],
                        "bbox": [50, 100, 300, 200],
                    },
                ],
            }
        ],
        "structure": {
            "tables": [{"page": 1, "bbox": [50, 100, 300, 200], "rows": 2, "cols": 2}],
            "figures": [],
            "text_blocks": [{"page": 1, "bbox": [50, 50, 200, 80], "text": "Sample Document"}],
        },
    }


def create_temp_json_file(tmp_path: Path, data: Dict[str, Any]) -> Path:
    """Create a temporary JSON file for testing"""
    json_file = tmp_path / "test.json"
    with open(json_file, "w") as f:
        json.dump(data, f, indent=2)
    return json_file
</file>

<file path="CODEOWNERS">
# Code owners for Johnny5 project

* @wawiesel
</file>

<file path="src/johnny5/server.py">
def run_web(pdf, port, fixup):
    """Launch the FastAPI web viewer for Johnny5"""
    from fastapi import FastAPI, WebSocket, WebSocketDisconnect
    from fastapi.staticfiles import StaticFiles
    from fastapi.templating import Jinja2Templates
    from fastapi.responses import HTMLResponse, FileResponse
    from fastapi import Request
    import uvicorn
    import json
    import logging
    import os
    from pathlib import Path
    import asyncio
    from typing import Dict

    app = FastAPI(title="Johnny5 Web Viewer")

    # Configure logging
    disassembly_logger = logging.getLogger("johnny5.disassembly")
    reconstruction_logger = logging.getLogger("johnny5.reconstruction")

    # Store active WebSocket connections
    active_connections: Dict[str, WebSocket] = {}

    # Mount static files
    static_path = Path(__file__).parent / "web" / "static"
    app.mount("/static", StaticFiles(directory=str(static_path)), name="static")

    # Setup templates
    templates_path = Path(__file__).parent / "web" / "templates"
    templates = Jinja2Templates(directory=str(templates_path))

    @app.get("/", response_class=HTMLResponse)
    async def root(request: Request):
        return templates.TemplateResponse("index.html", {"request": request, "pdf_path": str(pdf)})

    @app.get("/api/pdf")
    async def serve_pdf(file: str = None):
        """Serve the PDF file for PDF.js"""
        if file:
            # Handle different PDF files
            if file == "02-split_table.pdf":
                pdf_path = Path("examples/02-split_table/02-split_table.pdf")
            elif file == "01-one_page.pdf":
                pdf_path = Path("examples/01-one_page/01-one_page.pdf")
            else:
                pdf_path = pdf  # Default to the main PDF
        else:
            pdf_path = pdf

        if not pdf_path.exists():
            return {"error": f"PDF file not found: {pdf_path}"}

        return FileResponse(pdf_path, media_type="application/pdf")

    @app.get("/api/pdf-info")
    async def pdf_info():
        """Get PDF information for the web viewer"""
        return {"pdf_path": str(pdf), "fixup_module": fixup}

    @app.get("/api/structure/{page}")
    async def get_structure(page: int):
        """Get structure data for a specific page"""
        try:
            # Load structure from cache using JNY5_HOME
            jny5_home = Path(os.environ.get("JNY5_HOME", Path.home() / ".jny5"))
            cache_dir = jny5_home / "cache" / "structure"
            structure_file = cache_dir / "lossless_fixed.json"

            if not structure_file.exists():
                # Fallback to raw structure
                structure_file = cache_dir / "lossless.json"

            if not structure_file.exists():
                return {"error": "No structure data available"}

            with open(structure_file, "r", encoding="utf-8") as f:
                structure_data = json.load(f)

            # Find the requested page (1-indexed)
            if page < 1 or page > len(structure_data.get("pages", [])):
                return {"error": f"Page {page} not found"}

            page_data = structure_data["pages"][page - 1]
            return {
                "page": page_data,
                "metadata": structure_data.get("metadata", {}),
                "structure": structure_data.get("structure", {}),
            }

        except Exception as e:
            return {"error": f"Failed to load structure: {str(e)}"}

    @app.get("/api/density/{page}")
    async def get_density(page: int):
        """Get density data for visualization"""
        try:
            # Load structure from cache using JNY5_HOME
            jny5_home = Path(os.environ.get("JNY5_HOME", Path.home() / ".jny5"))
            cache_dir = jny5_home / "cache" / "structure"
            structure_file = cache_dir / "lossless_fixed.json"

            if not structure_file.exists():
                # Fallback to raw structure
                structure_file = cache_dir / "lossless.json"

            if not structure_file.exists():
                return {"error": "No density data available"}

            with open(structure_file, "r", encoding="utf-8") as f:
                structure_data = json.load(f)

            # Find the requested page (1-indexed)
            if page < 1 or page > len(structure_data.get("pages", [])):
                return {"error": f"Page {page} not found"}

            page_data = structure_data["pages"][page - 1]
            density_data = page_data.get("_density", {})

            return {
                "x": density_data.get("x", []),
                "y": density_data.get("y", []),
                "resolution": density_data.get("resolution", 50),
                "page_width": page_data.get("width", 0),
                "page_height": page_data.get("height", 0),
            }

        except Exception as e:
            return {"error": f"Failed to load density data: {str(e)}"}

    @app.websocket("/logs")
    async def websocket_logs(websocket: WebSocket):
        """WebSocket endpoint for streaming logs"""
        await websocket.accept()
        connection_id = f"conn_{len(active_connections)}"
        active_connections[connection_id] = websocket

        try:
            while True:
                # Keep connection alive
                await websocket.receive_text()
        except WebSocketDisconnect:
            del active_connections[connection_id]

    # Custom log handler to send logs to WebSocket clients
    class WebSocketLogHandler(logging.Handler):
        def emit(self, record):
            log_entry = {
                "timestamp": record.created,
                "level": record.levelname,
                "logger": record.name,
                "message": record.getMessage(),
                "module": record.module,
                "function": record.funcName,
                "line": record.lineno,
            }

            # Determine which pane this log should go to
            pane = "left"  # Default to left pane
            if "reconstruction" in record.name:
                pane = "right"

            log_entry["pane"] = pane

            # Send to all active connections
            for conn_id, websocket in list(active_connections.items()):
                try:
                    asyncio.create_task(websocket.send_text(json.dumps(log_entry)))
                except Exception:
                    # Remove dead connections
                    del active_connections[conn_id]

    # Add the custom handler to our loggers
    handler = WebSocketLogHandler()
    handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    handler.setFormatter(formatter)

    disassembly_logger.addHandler(handler)
    reconstruction_logger.addHandler(handler)
    disassembly_logger.setLevel(logging.DEBUG)
    reconstruction_logger.setLevel(logging.DEBUG)

    print(f"🚀 Starting Johnny5 web viewer on http://localhost:{port}")
    print(f"📄 PDF: {pdf}")
    print(f"🔧 Fixup: {fixup}")

    uvicorn.run(app, host="0.0.0.0", port=port)
</file>

<file path=".gitignore">
# Byte-compiled / optimized / DLL files
**/__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be added to the global gitignore or merged into this project gitignore.  For a PyCharm
#  project, it is recommended to include the following files:
#  .idea/
#  *.iml
#  *.ipr
#  *.iws
#  .idea/

# Johnny5 specific
_cache/
*.json
*.qmd
*.html
src/johnny5.egg-info/
*.DS_Store
**/.DS_Store
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.4
    hooks:
      - id: ruff
      - id: ruff-format
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.11.2
    hooks:
      - id: mypy
  - repo: local
    hooks:
      - id: validate-example-readmes
        name: Validate Example README Commands
        entry: bash scripts/pre-commit-hook
        language: system
        pass_filenames: false
        always_run: true
</file>

<file path="DESIGN.md">
# Johnny5 — Design

> SPEC = what the system must do.  
> DESIGN = how we implement it to meet the SPEC.  
> CONTRIBUTING = repo layout, coding standards, and workflow.

## 1. Architecture

### 1.1 Components
- **disassembler**: PDF → Docling lossless JSON → apply fixup → corrected JSON.
- **extractor**: corrected JSON → simplified content JSON.
- **reconstructor**: content JSON → QMD + HTML strings (and files).
- **server**: FastAPI app serving PDF.js UI, REST/WS APIs, static assets.
- **watcher**: hot-reload fixup modules, broadcast overlay updates.
- **utils**: pure functions (density, margins, context building).
- **fixups**: user-provided functions (per-PDF heuristics).

### 1.2 CLI Implementation

**Convenience Commands** (beyond SPEC.md requirements):
- `jny5 to-pdf <file>` - Render file to PDF based on file extension (currently supports .qmd using Quarto)
- `jny5 check <file>` - Check file for quality issues based on file extension (currently supports .qmd)

### 1.3 Data Flow
```
PDF (input)
└─ disassembler.run_disassemble(pdf, fixup.py)
├─ Docling → {JNY5_HOME}/cache/structure/{cache_key}.json
├─ fixup.py → {JNY5_HOME}/cache/structure/{cache_key}.json (same or different key)
└─ extractor.run_extract(fstructure_path, extractor.py)
└─ {JNY5_HOME}/cache/content/{cache_key}.json
└─ reconstructor.run_reconstruct(content_path, reconstructor.py)
└─ {JNY5_HOME}/cache/qmd/{cache_key}.qmd
└─ server (Johnny5 Web Interface)
├─ Left Pane: Y-Density, Annotated PDF, X-Density, Disassembly Log
├─ Right Pane: QMD/HTML Tabs, Reconstructed Output, Reconstruction Log
└─ WS /events (hot-reload pings)
```

### 1.4 Processes & Hot Reload
- `watcher` watches:
  - fixup modules under `src/johnny5/fixups/` and user-provided paths
  - cache files in `{JNY5_HOME}/cache/structure/`
- On change: re-run fixup → generate new cache key → notify via WS.

## 2. Modules & Contracts

### 2.1 disassembler.py
- `run_disassemble(pdf: Path, fixup: Path) -> str`
  - Generates cache key from PDF content and fixup file
  - Writes `{JNY5_HOME}/cache/structure/{cache_key}.json` (structure with fixup applied)
  - Returns cache key for downstream use
  - **CLI Output**: See SPEC.md for cache key emission and logging behavior
- Implementation notes:
  - Use Docling (pdfium backend). Store metadata with options + file hash.
  - Fixup loading: execute fixup.py with `FixupContext`.

### 2.2 extractor.py
- `run_extract(cache_key: str, extractor: Path) -> str`
  - Uses `{JNY5_HOME}/cache/structure/{cache_key}.json` as input
  - Converts structure JSON into content JSON using extractor.py
  - Writes `{JNY5_HOME}/cache/content/{new_cache_key}.json`
  - Returns new cache key for downstream use
  - **CLI Output**: See SPEC.md for cache key emission and logging behavior

### 2.3 reconstructor.py
- `run_reconstruct(cache_key: str, reconstructor: Path) -> str`
  - Uses `{JNY5_HOME}/cache/content/{cache_key}.json` as input
  - Converts content JSON into QMD using reconstructor.py
  - Writes `{JNY5_HOME}/cache/qmd/{new_cache_key}.qmd`
  - Returns new cache key for downstream use

### 2.4 server.py
- FastAPI (async) serving local files and visualization tools:
  - `GET /` → Johnny5 Web Interface with split-pane layout:
    - **Left Pane (Disassembly)**: 
      - X-Density banner above PDF with image indicators (d: original document, p: fixup JSON)
      - Y-Density banner to left of PDF
      - Annotated PDF with toggleable bounding boxes in center
      - Right gutter with annotations connected to bounding boxes
      - Terminal-like disassembly log at bottom
    - **Right Pane (Reconstruction)**:
      - X-Density banner above content with image indicator (q: content.json)
      - Y-Density banner to right of content
      - JSON/QMD/HTML Tabs with reconstructed output
      - Terminal-like reconstruction log at bottom
    - **Shared vertical scroll bar** for synchronized scrolling
  - `GET /doc` → metadata (page count, sizes).
  - `GET /pages/{n}/image?dpi=...` → raster via PyMuPDF (no quality loss controls in Matplotlib).
  - `GET /overlays/{n}` → clusters, colors, callouts.
  - `GET /density/{n}` → x/y density arrays + inferred margins.
  - `WS /events` → `{"type":"reload","page":n}` on fixup refresh.
- Static under `web/static`, templates under `web/templates`.
- Assumes local files exist; serves visualization and debugging tools.

### 2.5 watcher.py
- `watch_fixups(paths: list[Path], on_change: Callable[[], None])`
- Debounce 250–500 ms. Broadcast WS event after successful re-fixup.

### 2.6 utils/
- `density.py`
  - `compute_x_density(page) -> list[float]`
  - `compute_y_density(page) -> list[float]`
  - Units: PDF points (1/72 in). All bbox ops in points.
- `margins.py`
  - `infer_margins(page, *, pct=0.98) -> dict[left,right,top,bottom]` using coverage percentiles; no hardcoded px.
- `fixup_context.py`
  - `FixupContext` with page index, page size (points), cluster, style flags (bold/italic), normalized coords, and helpers.
  - Provide `is_bold(cell|cluster)`, `near_left_margin(cluster, margins, tol)`.

## 3. Naming & Files

- Cache: `{JNY5_HOME}/cache/{stage}/{cache_key}.{ext}` where stage is `structure`, `content`, or `qmd`
- Module names: `disassembler.py`, `extractor.py`, `reconstructor.py`, not verbs in function names except `run_*`
- Fixup signature: According to @SPEC.md

## 4. Error Handling

See SPEC.md for error handling specifications. Implementation follows the structured error hierarchy defined there.

## 5. Performance

* Page rasterization via PyMuPDF directly; cache pixmaps by `(page, dpi)`.
* Density/margin computations vectorized with NumPy where beneficial.
* Avoid re-parsing PDF when only fixups change.

## 6. Security

* Never execute arbitrary code outside designated fixup module path.
* Sandbox: if user supplies external path, require explicit `--allow-external-fixup`.

## 7. Testing Strategy

See CONTRIBUTING.md for testing framework and approach. Implementation follows pytest with unit tests, golden files, web tests, and cache key generation tests.

## 8. Non-Goals (for now)

* In-browser PDF parsing.
* OCR pipelines beyond Docling's toggle.
* WYSIWYG fixup editor (future).
</file>

<file path="pyproject.toml">
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "johnny5"
version = "0.1.0"
description = "Disassemble, fix, and reassemble structured documents using Docling"
authors = [{ name = "William Wieselquist" }]
license = "MIT"
readme = "README.md"
requires-python = ">=3.9"
dependencies = [
  "fastapi",
  "uvicorn[standard]",
  "python-multipart",
  "watchfiles",
  "docling",
  "docling-parse",
  "jinja2",
  "numpy",
  "click",
]

[project.urls]
Homepage = "https://github.com/wawiesel/johnny5"
Issues = "https://github.com/wawiesel/johnny5/issues"

[project.scripts]
jny5 = "johnny5.cli:main"

[tool.hatch.build.targets.wheel]
packages = ["src/johnny5"]

[tool.ruff]
line-length = 100
target-version = "py39"

[tool.black]
line-length = 100

[tool.mypy]
python_version = "3.9"
strict = true

[tool.pytest.ini_options]
addopts = "-q --tb=short"
testpaths = ["tests"]
</file>

<file path="TODO.md">
# Johnny5 TODO

A living checklist of remaining work and ideas.
Add to the bottom. Do not reorder.
Removed in the PR when they are complete.
There are other things to do of course, this is not an exhaustive list.

## Enable disassemble (no fixup) workflow

Enable the docling density and label display in the web viewer - show the X/Y density charts and label toggles for filtering annotations.
- Display annotations with on-the-fly toggles for all possible labels (based on docling spec)
- Visual indicators showing connection lines from PDF elements to annotations
- Implement tests to verify the workflow

## Enable caching system

Implement the content-based caching system described in @SPEC.md:
- Cache key generation from input file hash and fixup module
- JNY5_HOME environment variable support for cache location
- CLI commands to display cache keys
- Cache invalidation and cleanup mechanisms
- Foundation for hot reloading functionality

## Enable image panels for i and d

i is image based on checksum before fixup, d is after

## Enable disassemble with fixup

Enable the fixup with hot reloading, i.e. if the fixup.py changes on disk, it updates the annotations on-the-fly without restart. 
Figure out a reasonable way to test, possibly by monitoring a cache for expected files without cancelling the server. 
Might need to be able to run server in headless mode? 

## Implement content-based caching system

Implement the caching system described in @SPEC.md with cache key generation, 
JNY5_HOME environment variable support, and CLI commands that output cache keys.
This enables the full pipeline workflow and sets up the foundation for hot reloading.
</file>

<file path=".cursor/rules/important.mdc">
---
alwaysApply: true
---

# Johnny5 Cursor Rules

You are not allowed to change @.cursor/rules/important.mdc

You are johnny5-bot, the helpful expert developer for this repository. You never gaslight or apologize. You focus on your work and understanding the big picture while making each detail perfect.

## For you

- Avoid overly specific implementation details that will become outdated.
- Never hack around issues. For installation we're using a venv.
- Whenever you update Markdown, create aligned columns that are easy to read, even though it's not required by Markdown spec.
- Whenever you find something that seems inconsistent, either fix it or point it out. Don't just ignore it.

## Identity

- Use the `gh` CLI authenticated as **johnny5-bot** for all GitHub actions (push, PRs, reviews).
- Always make sure you are using johnny5-bot git credentials for every commit

## Authority

- Follow @SPEC.md (what it must do).
- Follow @DESIGN.md (how to implement).
- Follow @CONTRIBUTING.md (repo layout, coding standards, workflow).
- Frequently scan @TODO.md for next steps
</file>

<file path="src/johnny5/utils/density.py">
"""Johnny5 density calculation utilities

This module provides functions to compute horizontal and vertical density
of page elements for context-aware fixup processing.
"""

import logging
import numpy as np
from typing import List, Dict, Any, Tuple, Optional

logger = logging.getLogger(__name__)


def compute_horizontal_density(elements: List[Dict[str, Any]]) -> Dict[str, float]:
    """
    Compute horizontal density distribution of page elements.

    Args:
        elements: List of page elements with bbox coordinates

    Returns:
        Dictionary containing horizontal density metrics
    """
    if not elements:
        return {"left": 0.0, "center": 0.0, "right": 0.0}

    # Extract bbox coordinates
    bboxes = [elem.get("bbox", [0, 0, 0, 0]) for elem in elements]

    # Calculate horizontal density zones
    left_density = sum(1 for bbox in bboxes if bbox[0] < 0.33) / len(bboxes)
    center_density = sum(1 for bbox in bboxes if 0.33 <= bbox[0] <= 0.67) / len(bboxes)
    right_density = sum(1 for bbox in bboxes if bbox[0] > 0.67) / len(bboxes)

    return {
        "left": left_density,
        "center": center_density,
        "right": right_density,
    }


def compute_vertical_density(elements: List[Dict[str, Any]]) -> Dict[str, float]:
    """
    Compute vertical density distribution of page elements.

    Args:
        elements: List of page elements with bbox coordinates

    Returns:
        Dictionary containing vertical density metrics
    """
    if not elements:
        return {"top": 0.0, "middle": 0.0, "bottom": 0.0}

    # Extract bbox coordinates
    bboxes = [elem.get("bbox", [0, 0, 0, 0]) for elem in elements]

    # Calculate vertical density zones
    top_density = sum(1 for bbox in bboxes if bbox[1] < 0.33) / len(bboxes)
    middle_density = sum(1 for bbox in bboxes if 0.33 <= bbox[1] <= 0.67) / len(bboxes)
    bottom_density = sum(1 for bbox in bboxes if bbox[1] > 0.67) / len(bboxes)

    return {
        "top": top_density,
        "middle": middle_density,
        "bottom": bottom_density,
    }


def calculate_density(elements: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Calculate comprehensive density metrics for page elements.

    Args:
        elements: List of page elements with bbox coordinates

    Returns:
        Dictionary containing both horizontal and vertical density metrics
    """
    return {
        "horizontal": compute_horizontal_density(elements),
        "vertical": compute_vertical_density(elements),
    }


def compute_density_arrays(
    elements: List[Dict[str, Any]],
    page_width: float,
    page_height: float,
    resolution: Optional[int] = None,
) -> Tuple[List[float], List[float]]:
    """
    Compute density arrays for visualization.

    Args:
        elements: List of page elements with bbox coordinates
        page_width: Page width in points
        page_height: Page height in points
        resolution: Resolution for density arrays (auto-calculated if None)

    Returns:
        Tuple of (x_density_array, y_density_array)
    """
    if not elements:
        return [], []

    # Extract bounding boxes
    bboxes = []
    for elem in elements:
        bbox = elem.get("bbox", [0, 0, 0, 0])
        if len(bbox) == 4:
            bboxes.append(bbox)

    if not bboxes:
        return [], []

    # Calculate resolution if not provided
    if resolution is None:
        # Find the smallest meaningful dimension across all bounding boxes
        all_coords = []
        for bbox in bboxes:
            all_coords.extend(bbox)

        if all_coords:
            min_dimension = min(
                min(abs(bbox[2] - bbox[0]), abs(bbox[3] - bbox[1]))
                for bbox in bboxes
                if bbox[2] > bbox[0] and bbox[3] > bbox[1]
            )
            # Use 1/10th of smallest dimension as resolution, with reasonable bounds
            resolution = max(10, min(200, int(min_dimension / 10)))
        else:
            resolution = 50

    # Create density grids
    x_density = np.zeros(resolution)
    y_density = np.zeros(resolution)

    # Normalize coordinates to [0, 1] range
    for bbox in bboxes:
        x0, y0, x1, y1 = bbox

        # Convert to normalized coordinates
        norm_x0 = max(0, min(1, x0 / page_width))
        norm_x1 = max(0, min(1, x1 / page_width))
        norm_y0 = max(0, min(1, y0 / page_height))
        norm_y1 = max(0, min(1, y1 / page_height))

        # Calculate grid indices
        x_start = int(norm_x0 * resolution)
        x_end = int(norm_x1 * resolution)
        y_start = int(norm_y0 * resolution)
        y_end = int(norm_y1 * resolution)

        # Add density to grids
        for i in range(max(0, x_start), min(resolution, x_end + 1)):
            x_density[i] += 1

        for i in range(max(0, y_start), min(resolution, y_end + 1)):
            y_density[i] += 1

    return x_density.tolist(), y_density.tolist()


def calculate_document_resolution(pages: List[Dict[str, Any]]) -> int:
    """
    Calculate document-wide resolution parameter based on all bounding boxes.

    Args:
        pages: List of page data with elements

    Returns:
        Resolution parameter for density arrays
    """
    all_bboxes = []

    for page in pages:
        for element in page.get("elements", []):
            bbox = element.get("bbox", [0, 0, 0, 0])
            if len(bbox) == 4 and bbox[2] > bbox[0] and bbox[3] > bbox[1]:
                all_bboxes.append(bbox)

    if not all_bboxes:
        return 50  # Default resolution

    # Find smallest meaningful dimension
    min_dimensions = []
    for bbox in all_bboxes:
        width = bbox[2] - bbox[0]
        height = bbox[3] - bbox[1]
        min_dimensions.append(min(width, height))

    if min_dimensions:
        min_dimension = min(min_dimensions)
        # Use 1/10th of smallest dimension as resolution, with reasonable bounds
        resolution = max(10, min(200, int(min_dimension / 10)))
        return resolution

    return 50
</file>

<file path="src/johnny5/decomposer.py">
"""Johnny5 Decomposer - PDF to JSON conversion using Docling

This module handles the core PDF decomposition workflow:
1. PDF → Docling → lossless JSON
2. Apply fixup processing (hot-reloadable)
3. Save corrected JSON to _cache/
"""

import json
import logging
import importlib
import os
from pathlib import Path
from typing import Any, Dict, List, Optional

from docling.document_converter import DocumentConverter, FormatOption
from docling.datamodel.base_models import InputFormat
from docling.datamodel.pipeline_options import PdfPipelineOptions
from docling.pipeline.standard_pdf_pipeline import StandardPdfPipeline
from docling.backend.pypdfium2_backend import PyPdfiumDocumentBackend

from .utils.margins import analyze_page_margins
from .utils.density import (
    compute_horizontal_density,
    compute_vertical_density,
    compute_density_arrays,
    calculate_document_resolution,
)
from .utils.fixup_context import FixupContext

# Configure logging
logger = logging.getLogger(__name__)


def run_decompose(
    pdf: Path,
    layout_model: str,
    enable_ocr: bool,
    json_dpi: int,
    fixup: str,
) -> Path:
    """
    Convert a PDF into Docling lossless JSON, apply fixups, and write corrected output.

    Args:
        pdf: Path to the PDF file to process
        layout_model: Docling layout model to use (e.g., "pubtables", "hi_res")
        enable_ocr: Whether to enable OCR processing for text extraction
        json_dpi: DPI setting for JSON output generation
        fixup: Module path for fixup processing (hot-reloadable)

    Returns:
        Path to the corrected JSON file (_cache/lossless_fixed.json)

    Raises:
        FileNotFoundError: If PDF file doesn't exist
        ImportError: If fixup module can't be imported
        ValueError: If PDF processing fails
    """
    logger.info(f"Starting PDF decomposition: {pdf}")
    logger.info(f"Layout model: {layout_model}, OCR: {enable_ocr}, DPI: {json_dpi}")

    # Validate input
    if not pdf.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf}")

    # Create cache directory using JNY5_HOME environment variable
    jny5_home = Path(os.environ.get("JNY5_HOME", Path.home() / ".jny5"))
    cache_dir = jny5_home / "cache" / "structure"
    cache_dir.mkdir(parents=True, exist_ok=True)

    # Step 1: Convert PDF to lossless JSON using Docling
    logger.info("Converting PDF to lossless JSON using Docling")
    lossless_json_path = cache_dir / "lossless.json"

    try:
        docling_result = _run_docling_conversion(pdf, layout_model, enable_ocr, json_dpi)
        _write_json(docling_result, lossless_json_path)
        logger.info(f"Raw Docling output saved to: {lossless_json_path}")

    except Exception as e:
        logger.error(f"Docling conversion failed: {e}")
        raise ValueError(f"PDF processing failed: {e}") from e

    # Step 2: Apply fixup processing (skipping for now)
    logger.info("Skipping fixup processing")
    corrected_json_path = cache_dir / "lossless_fixed.json"

    try:
        # For now, just copy the raw output without applying fixups
        _write_json(docling_result, corrected_json_path)
        logger.info(f"Output saved to: {corrected_json_path}")

    except Exception as e:
        logger.error(f"Failed to save output: {e}")
        raise

    logger.info("PDF decomposition completed successfully")
    return corrected_json_path


def _run_docling_conversion(
    pdf: Path, layout_model: str, enable_ocr: bool, json_dpi: int
) -> Dict[str, Any]:
    """
    Convert PDF to lossless JSON using Docling DocumentConverter.

    Args:
        pdf: Path to PDF file
        layout_model: Layout model to use
        enable_ocr: Whether to enable OCR
        json_dpi: DPI for JSON output

    Returns:
        Dictionary containing Docling's lossless JSON structure
    """
    logger.debug(f"Initializing Docling converter with model: {layout_model}")

    # Configure FormatOption for PDF with all required parameters
    pdf_opts = FormatOption(
        format="lossless-json",
        include_layout=True,
        layout_model=layout_model,
        enable_ocr=enable_ocr,
        dpi=json_dpi,
        backend=PyPdfiumDocumentBackend,
        pipeline_cls=StandardPdfPipeline,
    )

    # Initialize converter with FormatOption
    converter = DocumentConverter(format_options={InputFormat.PDF: pdf_opts})

    # Convert document
    logger.debug("Running Docling conversion")
    result = converter.convert(str(pdf))

    # Extract the document structure - use model_dump() to get the full structure
    doc_dict = result.model_dump()

    # Build our JSON structure from the Docling output
    json_data = {
        "metadata": {
            "source_pdf": str(pdf),
            "layout_model": layout_model,
            "ocr_enabled": enable_ocr,
            "json_dpi": json_dpi,
        },
        "pages": [],
        "structure": {
            "tables": [],
            "figures": [],
            "text_blocks": [],
        },
    }

    # Extract pages from Docling's structure
    # The working code uses doc["pages"] so we should use that format
    pages = doc_dict.get("pages", [])

    all_pages_data = []
    for page_idx, page_dict in enumerate(pages):
        logger.debug(f"Processing page {page_idx + 1}")

        # Get page dimensions from page size
        size = page_dict.get("size", {})
        if isinstance(size, dict):
            width = size.get("width", 612)
            height = size.get("height", 792)
        else:
            width = 612
            height = 792

        page_data = {
            "page_number": page_idx + 1,
            "width": width,
            "height": height,
            "elements": [],
        }

        # Process page predictions/layout to extract elements
        predictions = page_dict.get("predictions", {})
        layout = predictions.get("layout", {})
        clusters = layout.get("clusters", [])

        for cluster in clusters:
            element_data = _extract_element_data_from_cluster(cluster, page_idx + 1, width, height)
            if element_data:
                page_data["elements"].append(element_data)

        all_pages_data.append(page_data)

    # Calculate document-wide resolution
    doc_resolution = calculate_document_resolution(all_pages_data)
    logger.debug(f"Document resolution for density arrays: {doc_resolution}")

    # Now process each page with density arrays
    for page_data in all_pages_data:
        # Analyze page-level properties
        page_data["margins"] = analyze_page_margins(page_data["elements"])
        page_data["horizontal_density"] = compute_horizontal_density(page_data["elements"])
        page_data["vertical_density"] = compute_vertical_density(page_data["elements"])

        # Compute density arrays for visualization
        x_density, y_density = compute_density_arrays(
            page_data["elements"], page_data["width"], page_data["height"], doc_resolution
        )
        page_data["_density"] = {"x": x_density, "y": y_density, "resolution": doc_resolution}

        json_data["pages"].append(page_data)

    # Extract structural information
    json_data["structure"] = _extract_document_structure(json_data["pages"])

    logger.info(f"Successfully converted PDF with {len(json_data['pages'])} pages")
    return json_data


def _extract_element_data_from_cluster(
    cluster: Dict[str, Any], page_number: int, page_width: float, page_height: float
) -> Optional[Dict[str, Any]]:
    """
    Extract structured data from a Docling cluster (from lossless JSON format).

    Args:
        cluster: Docling cluster dictionary
        page_number: Page number for context
        page_width: Page width in points
        page_height: Page height in points

    Returns:
        Dictionary containing element data, or None if element should be skipped
    """
    try:
        # Extract label/type
        label = cluster.get("label", "unknown")

        # Extract bounding box
        bbox_dict = cluster.get("bbox", {})
        if isinstance(bbox_dict, dict):
            # Format: {"l": left, "t": top, "r": right, "b": bottom}
            x0 = bbox_dict.get("l", 0)
            y0 = bbox_dict.get("t", 0)
            x1 = bbox_dict.get("r", page_width)
            y1 = bbox_dict.get("b", page_height)
        elif isinstance(bbox_dict, list) and len(bbox_dict) == 4:
            x0, y0, x1, y1 = bbox_dict
        else:
            return None

        element_data = {
            "type": label,
            "page": page_number,
            "bbox": [x0, y0, x1, y1],
            "confidence": cluster.get("confidence", 1.0),
        }

        # Extract text content
        if "text" in cluster:
            element_data["content"] = str(cluster["text"]).strip()
        elif "cells" in cluster:
            # Extract text from cells
            text_parts = []
            for cell in cluster.get("cells", []):
                if isinstance(cell, dict) and "text" in cell:
                    text_parts.append(cell["text"])
                elif isinstance(cell, str):
                    text_parts.append(cell)
            if text_parts:
                element_data["content"] = " ".join(text_parts)

        return element_data

    except Exception as e:
        logger.warning(f"Failed to extract element data from cluster: {e}")
        return None


def _extract_table_data(table: Any) -> Dict[str, Any]:
    """Extract structured data from a Docling table."""
    return {
        "rows": len(table.rows) if hasattr(table, "rows") else 0,
        "cols": len(table.cols) if hasattr(table, "cols") else 0,
        "cells": [
            {
                "row": cell.row_idx,
                "col": cell.col_idx,
                "content": cell.text if hasattr(cell, "text") else "",
                "bbox": [cell.bbox.x0, cell.bbox.y0, cell.bbox.x1, cell.bbox.y1],
            }
            for cell in getattr(table, "cells", [])
        ],
    }


def _extract_figure_data(figure: Any) -> Dict[str, Any]:
    """Extract structured data from a Docling figure."""
    return {
        "caption": getattr(figure, "caption", ""),
        "image_path": getattr(figure, "image_path", ""),
        "bbox": [figure.bbox.x0, figure.bbox.y0, figure.bbox.x1, figure.bbox.y1],
    }


def _extract_document_structure(pages: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """
    Extract high-level document structure from processed pages.

    Args:
        pages: List of processed page data

    Returns:
        Dictionary containing tables, figures, and text blocks
    """
    structure = {
        "tables": [],
        "figures": [],
        "text_blocks": [],
    }

    for page in pages:
        page_num = page["page_number"]

        for element in page["elements"]:
            if element["type"] == "table":
                structure["tables"].append(
                    {
                        "page": page_num,
                        "bbox": element["bbox"],
                        "rows": element.get("table", {}).get("rows", 0),
                        "cols": element.get("table", {}).get("cols", 0),
                    }
                )
            elif element["type"] == "figure":
                structure["figures"].append(
                    {
                        "page": page_num,
                        "bbox": element["bbox"],
                        "caption": element.get("figure", {}).get("caption", ""),
                    }
                )
            elif element["type"] in ["text", "title", "heading"]:
                structure["text_blocks"].append(
                    {
                        "page": page_num,
                        "bbox": element["bbox"],
                        "text": element.get("content", ""),
                        "type": element["type"],
                    }
                )

    return structure


def _apply_fixup_rules(docling_result: Dict[str, Any], fixup: str, pdf: Path) -> Dict[str, Any]:
    """
    Apply fixup processing to Docling result using the specified module.

    Args:
        docling_result: Raw Docling JSON result
        fixup: Module path for fixup processing
        pdf: Original PDF path for context

    Returns:
        Corrected JSON result after fixup processing
    """
    logger.debug(f"Loading fixup module: {fixup}")

    try:
        # Import fixup module (hot-reloadable)
        module = importlib.import_module(fixup)

        if not hasattr(module, "apply_fixup"):
            logger.warning(f"Fixup module {fixup} missing apply_fixup function")
            return docling_result

        # Create fixup context
        context = FixupContext(
            pdf_path=pdf,
            pages=docling_result["pages"],
            structure=docling_result["structure"],
            metadata=docling_result["metadata"],
        )

        # Apply fixup processing
        logger.debug("Applying fixup processing to document")
        corrected_result = module.apply_fixup(context)

        if corrected_result is None:
            logger.warning("Fixup module returned None, using original result")
            return docling_result

        # Recompute density arrays for corrected result
        logger.debug("Recomputing density arrays after fixup")
        corrected_result = _recompute_density_arrays(corrected_result)

        logger.info("Fixup processing completed successfully")
        return corrected_result

    except ImportError as e:
        logger.error(f"Failed to import fixup module {fixup}: {e}")
        raise ImportError(f"Could not import fixup module: {fixup}") from e
    except Exception as e:
        logger.error(f"Fixup processing failed: {e}")
        logger.warning("Using original Docling result as fallback")
        return docling_result


def _recompute_density_arrays(result: Dict[str, Any]) -> Dict[str, Any]:
    """
    Recompute density arrays after fixup processing.

    Args:
        result: Document result (may be modified by fixup)

    Returns:
        Result with updated density arrays
    """
    # Calculate document-wide resolution
    doc_resolution = calculate_document_resolution(result["pages"])

    # Update density arrays for each page
    for page_data in result["pages"]:
        x_density, y_density = compute_density_arrays(
            page_data["elements"], page_data["width"], page_data["height"], doc_resolution
        )
        page_data["_density"] = {"x": x_density, "y": y_density, "resolution": doc_resolution}

    return result


def _write_json(data: Dict[str, Any], output_path: Path) -> None:
    """
    Write JSON data to file with proper encoding and formatting.

    Args:
        data: Dictionary to serialize as JSON
        output_path: Path where to write the JSON file
    """
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)


def load_docling_pipeline(layout_model: str, enable_ocr: bool) -> DocumentConverter:
    """
    Load and configure Docling pipeline with specified options.

    Args:
        layout_model: Layout model to use
        enable_ocr: Whether to enable OCR

    Returns:
        Configured DocumentConverter instance
    """
    logger.debug(f"Loading Docling pipeline: model={layout_model}, ocr={enable_ocr}")

    pipeline_options = PdfPipelineOptions()
    pipeline_options.do_ocr = enable_ocr
    pipeline_options.do_table_structure = True
    pipeline_options.table_structure_options.do_cell_matching = True

    converter = DocumentConverter(
        format_options={
            InputFormat.PDF: pipeline_options,
        },
    )

    return converter


def apply_fixups(content: Dict[str, Any], fixup: str) -> Dict[str, Any]:
    """
    Apply fixup processing to extracted content.

    Args:
        content: Document content dictionary
        fixup: Module path for fixup processing

    Returns:
        Corrected content after fixup processing
    """
    return _apply_fixup_rules(content, fixup, Path("unknown.pdf"))
</file>

<file path="CONTRIBUTING.md">
# Contributing to Johnny5

All contributors (humans and automation) must follow the same standards.

---

## 🧩 Coding Standards

- Python ≥ 3.9  
- 100-character line limit (Black + Ruff)
- 50-line function limit
- Full type hints required  
- Use `pathlib.Path`, not raw strings  
- Use `logging`, not `print()`  
- No mutable globals  
- Be DRY. Please. I'm begging you.

---

## 🧪 Testing

- Framework: **pytest**  
- Tests mirror the module structure.

### Running Tests

```bash
pytest                    # Run all tests
pytest -v                 # Verbose output
pytest tests/test_basic.py # Run specific test file
```  

## 🔧 Development Setup

### Virtual Environment

```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -e .
```

### Pre-commit Hooks

```bash
pip install pre-commit
pre-commit install
```

This will run `ruff check`, `ruff-format`, and `mypy` on every commit.

The pre-commit hooks will also validate example README files by running the commands they contain to ensure they work correctly.

**Note**: Some commands may modify files (like generating PDFs), but the hook handles this appropriately to avoid git conflicts.


---

## 🧭 Development Workflow

1. Create a new branch (`feat/`, `fix/`, or `refactor/`).
2. Make changes following the module boundaries.
3. Ensure lint, format, and tests pass.
4. Commit with [Conventional Commits](https://www.conventionalcommits.org/).
5. Push and open a PR into `main`.
6. Wait for review of the PR.
7. Note: all commits must be signed.

---

## 🌐 FastAPI Guidelines

* Use async endpoints.
* Externalize HTML/JS/CSS assets to `web/static` or `web/templates`.
* Prefer composition and helpers in `utils/` over large functions.

---

## ✅ Summary

All code, whether by humans or automation, must:

* Follow these standards.
* Include tests.
* Pass CI.
</file>

<file path="SPEC.md">
# Johnny5 Specification

## 1. Scope

Johnny5 provides a reproducible, pluggable environment for document disassembly and reassembly.

### Core Requirements

1. **Disassemble PDFs** into a structured, lossless JSON using Docling.
2. **Apply a python code fixup** for aided disassembly with hot reload.
3. **Define a python code extraction spec** for aided extraction to a content JSON with hot reload.
4. **Define a python code reconstruct spec** for creation of a text document from that JSON only.
5. **Provide a web interface** for inspection and debugging.

---

## 2. Functional Specification

### CLI Commands

```bash
jny5 disassemble <pdf> --fixup <fixup.py> [docling-options]
# Outputs cache key: a1b2c3d4e5f6g7h8
# Creates: ~/.jny5/cache/structure/a1b2c3d4e5f6g7h8.json (raw)
#          ~/.jny5/cache/structure/b2c3d4e5f6g7h8i9.json (fixed)
```

```bash
jny5 extract <extract.py> --from-cache b2c3d4e5f6g7h8i9
# Uses: ~/.jny5/cache/structure/b2c3d4e5f6g7h8i9.json
# Outputs cache key: c3d4e5f6g7h8i9j0
# Creates: ~/.jny5/cache/content/c3d4e5f6g7h8i9j0.json
```

```bash
jny5 reconstruct <reconstruct.py> --from-cache c3d4e5f6g7h8i9j0
# Uses: ~/.jny5/cache/content/c3d4e5f6g7h8i9j0.json
# Outputs cache key: d4e5f6g7h8i9j0k1
# Creates: ~/.jny5/cache/qmd/d4e5f6g7h8i9j0k1.qmd
```

```bash
jny5 view <pdf> [--fixup <fixup.py> --extract <extract.py> --reconstruct <reconstruct.py> docling-options]
# Open the webviewer
```

### Content-Based Caching System

Johnny5 uses a sophisticated content-based caching system where inputs are checksummed to generate cache keys, and outputs are stored with filenames equal to those cache keys.

#### Content Types

| Type              | Description                                    | Shortcut Reference |
|-------------------|------------------------------------------------|--------------------|
| **Structure**     | Docling lossless JSON structure                | `structure.json`   |
| **Structure**     | Corrected structure after fixup                | `fstructure.json`  |
| **Content**       | Extracted pure content description             | `content.json`     |
| **Markdown**      | Content rendered as text format                | `content.qmd`      |
| **HTML**          | Content rendered for viewing                   | `content.html`     |

#### Cache Directory Configuration

Johnny5 uses the `JNY5_HOME` environment variable to determine the cache location:
- **Default**: `~/.jny5` (if `JNY5_HOME` is not set)
- **Cache directory**: `{JNY5_HOME}/cache/`
- **Example**: With `JNY5_HOME=/opt/johnny5`, cache files are stored in `/opt/johnny5/cache/`

#### Cache Key Generation

Each stage generates a cache key by checksumming all relevant inputs. The cache key is a 16-character SHA-256 hash derived from the sorted JSON representation of all input content.

#### Cache Key Sources by Stage

| Stage           | Cache Key Sources                           | Example Key        |
|-----------------|---------------------------------------------|--------------------|
| **Disassemble** | PDF content + Docling options               | `a1b2c3d4e5f6g7h8` |
| **Fixup**       | structure.json content + fixup.py content   | `b2c3d4e5f6g7h8i9` |
| **Extract**     | fstructure.json content + extract.py content| `c3d4e5f6g7h8i9j0` |
| **Reconstruct** | content.json content + reconstruct.py content | `d4e5f6g7h8i9j0k1` |

#### Cache File Naming

All cache files use subdirectories with consistent naming: `{JNY5_HOME}/cache/{stage}/{cache_key}.{ext}`

**Structure Stage**: Both raw Docling output and fixup-processed structure files are stored in the same `structure/` directory:
- `~/.jny5/cache/structure/a1b2c3d4e5f6g7h8.json` (raw Docling output)
- `~/.jny5/cache/structure/b2c3d4e5f6g7h8i9.json` (fixed structure after fixup)

**Other Stages**:
- `~/.jny5/cache/content/c3d4e5f6g7h8i9j0.json` (extracted content)
- `~/.jny5/cache/qmd/d4e5f6g7h8i9j0k1.qmd` (reconstructed QMD)

**Note**: When fixup is null/empty, structure and fstructure cache keys are identical, storing the same file. The raw and fixed files can coexist in the same directory with different cache keys.


#### Cache Key Emission

Every command outputs its generated cache key to stdout for chaining. All logging, progress, and diagnostic information goes to stderr to avoid interfering with cache key capture.

```bash
# Example workflow
STRUCTURE_KEY=$(jny5 disassemble document.pdf --fixup fixup.py)
FSTRUCTURE_KEY=$(jny5 extract extract.py --from-cache $STRUCTURE_KEY)
CONTENT_KEY=$(jny5 reconstruct reconstruct.py --from-cache $FSTRUCTURE_KEY)
jny5 view document.pdf --fixup fixup.py --extract extract.py --reconstruct reconstruct.py
```

#### Cache Benefits

- **Deterministic**: Same inputs always produce same cache key
- **Efficient**: Skip processing when cache exists
- **Reliable**: No manual file manipulation required
- **Traceable**: Cache keys provide audit trail
- **Parallel-safe**: Multiple processes can use same cache

### Python Module Callable Contracts

Each Python script must export a single callable with the following signatures:

**Note**: `FixupContext` provides page index, page size (points), cluster data, style flags (bold/italic), normalized coordinates, and helper methods like `is_bold()`, `near_left_margin()`, etc.

```python
# fixup.py
def fixup(structure: dict) -> dict:
    """Return modified structure JSON."""

# extract.py
def extract(fstructure: dict) -> dict:
    """Return simplified content JSON."""

# reconstruct.py
def reconstruct(content: dict) -> str:
    """Return reconstructed text (QMD)."""
```

### Web Application

The Johnny5 web interface provides a split-pane layout for visualizing PDF disassembly and reconstruction processes. The interface is designed with **primary content areas** for the main workflow and **supporting data panels** for debugging and analysis.

#### Layout Structure

**Primary Content (Main Focus):**
- **Left Pane**: PDF Viewer - displays the actual PDF page with toggleable bounding boxes
- **Right Pane**: Reconstructed Content - shows JSON/QMD/HTML output

**Supporting Data (Secondary Information):**
- **X-Density Banners**: Horizontal density charts at the top of both panes
- **Y-Density Sidebars**: Vertical density charts positioned asymmetrically
  - Left side of left pane
  - Right side of right pane
- **Annotations Gutter**: Thin labels (30 chars max) on right side of left pane
  - Shows element types like "section_header", "table", etc.
- **Log Terminals**: Process logs at bottom of both panes
- **Image Indicators**: State indicators (d, p, q) showing data source status

#### Visual Layout
```
Left Pane:  [Y-Density] | [PDF Viewer] | [Annotations]
Right Pane: [Reconstructed Content] | [Y-Density]
```

The PDF viewer and reconstructed content are the **primary focus** - they should be the largest, most prominent areas. All other elements are **supporting information** to help understand and debug the disassembly/reconstruction process.

```
┌─────────────────────────────┐───┌──────────────────────────┐
│  i  |     X-Density     | d │ e │       X-Density    | r   │
├─────┬───────────────────┬───┤───├──────────────────────────┤
│     │                   │       │                    |     │
│ Y-  │   Annotated       │An-    │ Reconstructed      | Y-  │
│ Den │     PDF +         │not    │ Content            | Den │
│ sity│   Toggleable      │at-    │ [JSON|QMD|HTML]    │ sity│
│     │   Bounding        │ion    │                    │     │
│     │     Boxes         │s      │                    │     │
│     │                   │       │                    │     │
├─────┴───────────────────┴────────────────────────────┴─────┤
│   Disassemble options   │  label│  Reconstruct options     │
├─────────────────────────│ sel=  │──────────────────────────┤
│    Disassembly Log      │ ect   │  Reconstruction Log      │
│    (Terminal Output)    │       │  (Terminal Output)       │
└─────────────────────────┴──────-┴──────────────────────────┘  

```

**Image Indicators:**

- **i**: Original document image - changes when the underlying PDF changes or Docling processing options change
- **d**: Fixup JSON image - represents the content of the fixup JSON (if d==i, no fixups are needed)
- **e**: Extraction content JSON image
- **r**: Reconstruction content JSON image

Here is a wireframe with the components.


```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wireframe Layout</title>
    <style>
        body, html {
            margin: 0;
            height: 100vh;
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
            color: #fff;
            font-size: 14px;
            background-color: #111;
            overflow: hidden; /* Prevent body scroll */
        }

        .app-container {
            display: grid;
            height: 100vh;
            width: 100vw;
            grid-template-columns: 50px 1fr 50px 50px 2px 1fr 50px;
            grid-template-rows: 40px 1fr 80px 100px;
            gap: 1px;
            background-color: #000;
        }

        /* Helper class for all boxes */
        .box {
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            text-align: center;
        }
        
        /* Helper for light boxes that need dark text */
        .dark-text {
            color: #333;
        }

        /* --- RED HUES --- */
        #indicator-i {
            grid-row: 1 / 2; grid-column: 1 / 2;
            background-color: #ff4747; /* red */
        }
        #indicator-d {
            grid-row: 1 / 2; grid-column: 3 / 4;
            background-color: #ff6347; /* tomato */
        }
        #indicator-e {
            grid-row: 1 / 2; grid-column: 4 / 5;
            background-color: #ff7f50; /* coral */
        }
        #indicator-r {
            grid-row: 1 / 2; grid-column: 7 / 8;
            background-color: #dc143c; /* crimson */
        }

        /* --- GREEN/YELLOW HUES --- */
        #x-density {
            grid-row: 1 / 2; grid-column: 2 / 3;
            background-color: #9acd32; /* yellowgreen */
        }
        #y-density {
            grid-row: 2 / 3; grid-column: 1 / 2;
            background-color: #2e8b57; /* seagreen */
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }
        #pdf-viewer {
            grid-row: 2 / 3; grid-column: 2 / 3;
            background-color: #98fb98; /* palegreen */
        }
        #x-density-right {
            grid-row: 1 / 2; grid-column: 6 / 7;
            background-color: #ffd700; /* gold */
        }
        #reconstructed {
            grid-row: 2 / 3; grid-column: 6 / 7;
            background-color: #ffffe0; /* lightyellow */
        }
        #y-density-right {
            grid-row: 2 / 3; grid-column: 7 / 8;
            background-color: #f0e68c; /* khaki */
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }

        /* --- BLUE HUES --- */
        #annotations {
            grid-row: 2 / 3; grid-column: 3 / 5; /* Spans 2 cols */
            background-color: #00ffff; /* cyan */
        }
        #toggles {
            grid-row: 3 / 5; grid-column: 3 / 5; /* Spans 2 rows, 2 cols */
            background-color: #007fff; /* azure */
        }

        /* --- PURPLE HUES --- */
        #options {
            grid-row: 3 / 4; grid-column: 1 / 3; /* Spans 2 cols */
            background-color: #8a2be2; /* blueviolet */
        }
        #options-right {
            grid-row: 3 / 4; grid-column: 6 / 8; /* Spans 2 cols */
            background-color: #9932cc; /* darkorchid */
        }
        
        /* --- ORANGE HUES --- */
        #log {
            grid-row: 4 / 5; grid-column: 1 / 3; /* Spans 2 cols */
            background-color: #ffa500; /* orange */
        }
        #log-right {
            grid-row: 4 / 5; grid-column: 6 / 8; /* Spans 2 cols */
            background-color: #ff8c00; /* darkorange */
        }


        /* --- CENTER DIVIDER --- */
        .center-divider {
            grid-row: 1 / 5; grid-column: 5 / 6; /* Spans all 4 rows */
            background-color: #555;
        }
    </style>
</head>
<body>

    <div class="app-container">
        <div id="indicator-i" class="box">i</div>
        <div id="x-density" class="box dark-text">X-Density</div>
        <div id="indicator-d" class="box">d</div>
        <div id="indicator-e" class="box">e</div>
        <div id="y-density" class="box">Y-Density</div>
        <div id="pdf-viewer" class="box dark-text">PDF Viewer</div>
        <div id="annotations" class="box dark-text">Label Annotations</div>
        <div id="options" class="box">Disassemble Options</div>
        <div id="log" class="box dark-text">Disassemble Log</div>
        <div id="toggles" class="box">Label Toggles</div>

        <div class="center-divider"></div>

        <div id="x-density-right" class="box dark-text">X-Density</div>
        <div id="indicator-r" class="box">r</div>
        <div id="reconstructed" class="box dark-text">Reconstructed</div>
        <div id="y-density-right" class="box dark-text">Y-Density</div>
        <div id="options-right" class="box">Reconstruct Options</div>
        <div id="log-right" class="box dark-text">Reconstruct Log</div>
    </div>

</body>
</html>
```

### Web Interface Requirements

- **Synchronized scrolling**: The vertical scroll bar must scroll both panes simultaneously to maintain alignment between disassembly and reconstruction views
- **Responsive**: The web UI must be responsive to movements.
- **Beautiful**: The PDF render should be crisp and easy to read.
</file>

<file path="tests/test_basic.py">
"""Basic tests for Johnny5 package"""

from johnny5 import __version__


def test_version():
    """Test that version is properly defined"""
    assert isinstance(__version__, str)
    assert len(__version__) > 0


def test_package_imports():
    """Test that all main functions can be imported"""
    from johnny5 import main, run_decompose, json_to_qmd, json_to_html, run_web

    assert main is not None
    assert run_decompose is not None
    assert json_to_qmd is not None
    assert json_to_html is not None
    assert run_web is not None


def test_cli_group():
    """Test that CLI group is properly configured"""
    from johnny5.cli import main as cli_main

    assert cli_main.name == "main"
    # Test that CLI commands exist (number may vary)
    assert "disassemble" in cli_main.commands
    assert "web" in cli_main.commands


def test_decomposer_placeholder():
    """Test decomposer placeholder functionality"""
    from johnny5.decomposer import run_decompose
    import inspect

    # Test that the function exists and has the right signature
    sig = inspect.signature(run_decompose)
    assert "pdf" in sig.parameters
    assert "layout_model" in sig.parameters
    assert "enable_ocr" in sig.parameters
    assert "json_dpi" in sig.parameters
    assert "fixup" in sig.parameters


def test_recomposer_placeholder():
    """Test recomposer placeholder functionality"""
    from johnny5.recomposer import json_to_qmd, json_to_html
    import inspect

    # Test json_to_qmd signature
    sig_qmd = inspect.signature(json_to_qmd)
    assert "json_path" in sig_qmd.parameters
    assert "output_path" in sig_qmd.parameters

    # Test json_to_html signature
    sig_html = inspect.signature(json_to_html)
    assert "json_path" in sig_html.parameters
    assert "output_path" in sig_html.parameters
</file>

<file path="src/johnny5/web/static/app.css">
/* Johnny5 Web Viewer Styles - Grid Layout */

* {
    box-sizing: border-box;
}

body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background-color: #f5f5f5;
    overflow: hidden;
}

#app {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

.app-container {
    display: grid;
    height: 100vh;
    width: 100vw;
    grid-template-columns: 50px 1fr 50px 50px 2px 1fr 50px;
    grid-template-rows: 40px 1fr 80px 100px;
    gap: 1px;
    background-color: #000;
}

/* Helper class for all boxes */
.box {
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    text-align: center;
}

/* Helper for light boxes that need dark text */
.dark-text {
    color: #333;
}

/* --- RED HUES - Image Indicators --- */
#indicator-i {
    grid-row: 1 / 2; grid-column: 1 / 2;
    background-color: #ff4747;
    cursor: pointer;
}

#indicator-d {
    grid-row: 1 / 2; grid-column: 3 / 4;
    background-color: #ff6347;
    cursor: pointer;
}

#indicator-e {
    grid-row: 1 / 2; grid-column: 4 / 5;
    background-color: #ff7f50;
    cursor: pointer;
}

#indicator-r {
    grid-row: 1 / 2; grid-column: 7 / 8;
    background-color: #dc143c;
    cursor: pointer;
}

/* --- GREEN/YELLOW HUES - Density Charts --- */
#x-density {
    grid-row: 1 / 2; grid-column: 2 / 3;
    background-color: #9acd32;
    position: relative;
    overflow-x: auto;
    overflow-y: hidden;
}

#y-density {
    grid-row: 2 / 3; grid-column: 1 / 2;
    background-color: #2e8b57;
    position: relative;
    overflow: auto; /* Must be scrollable */
    height: 100%;
    display: block; /* no flex; no alignment games */
    padding: 0;     /* critical: no padding or you’ll be offset */
    /* Hide scrollbar but keep functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}

/* Ensure the ruler canvas doesn’t shrink in a flex context anywhere */
#y-density > canvas {
    display: block;
    width: 100%;
    flex: none;
}

/* Hide scrollbar for WebKit browsers (Chrome, Safari) */
#y-density::-webkit-scrollbar {
    display: none;
}

/* Density Chart Canvas */
#x-density-chart,
#x-density-right-chart {
    width: 100%;
    height: 100%;
    display: block;
}

#y-density-chart,
#y-density-right-chart {
    width: 100%;
    display: block;
    flex-shrink: 0;
}



#pdf-viewer {
    grid-row: 2 / 3; grid-column: 2 / 3;
    background-color: #eaeaea; /* light grey behind scroller */
    position: relative; /* Anchor for absolutely positioned controls */
    height: 100%;
    display: flex; /* Override .box to control flow */
    flex-direction: column;
}

/* PDF Scroller - Handles the actual scrolling */
#pdf-scroller {
    position: relative; /* For the canvas container inside */
    width: 100%;
    flex-grow: 1; /* Makes it fill all available vertical space */
    
    /* All the scrolling properties moved here */
    overflow: auto;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch; /* iOS smooth scrolling */
    will-change: scroll-position; /* Optimize for scrolling */
    max-height: none; /* Remove any height constraints */
    max-width: none; /* Allow horizontal scrolling */
    background-color: #f2f2f2; /* light grey behind PDF pages */
}

/* Grid and overlay layers inside the PDF scroller */
#overlay-container,
#pdf-grid {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    pointer-events: none;
}

#pdf-grid {
    z-index: 2; /* Above canvas, below controls */
}

#overlay-container {
    z-index: 3; /* Annotations above grid */
}

/* Left ruler overlay inside the PDF scroller */
#left-ruler {
    position: absolute;
    top: 0;
    left: 0;
    width: 36px; /* display width; backing store set in JS */
    pointer-events: none;
    z-index: 2; /* same layer as grid */
}

/* PDF origin marker (bottom-left of each page in PDF space) */
.origin-marker {
    position: absolute;
    width: 12px;
    height: 12px;
    border: 2px solid rgba(120,120,120,0.9);
    border-radius: 50%;
    background: transparent;
    pointer-events: none;
    box-sizing: border-box;
    z-index: 3; /* above grid */
}

/* PDF Controls Overlay */
.pdf-controls-overlay {
    /* Position absolutely within #pdf-viewer */
    position: absolute;
    top: 15px;
    right: 15px;
    
    /* Ensure it's on top */
    z-index: 10000; /* Always above grid/overlays */
    
    /* Styling - match page count overlay size */
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    padding: 0.35rem 0.5rem;
    display: flex;
    flex-direction: row; /* Single row of controls */
    gap: 0.25rem;
    align-items: center;
    opacity: 0.4;
    transition: all 0.3s ease;
    backdrop-filter: blur(4px);
    pointer-events: auto; /* Allow clicking on controls */
}

.pdf-controls-overlay:hover {
    opacity: 1;
    background: rgba(0, 0, 0, 0.7);
    transform: scale(1.05);
}

#page-count-overlay {
    position: absolute;
    top: 15px;
    left: 15px; /* Placed in top-left */
    z-index: 100;
    
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(4px);
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    font-size: 0.8rem;
    font-weight: 600;
    pointer-events: none; /* Prevents it from blocking clicks */
}

.pdf-controls-overlay .control-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.8rem;
}

.pdf-controls-overlay .control-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 0.2rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.7rem;
    transition: all 0.2s;
    min-width: 24px;
    min-height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.pdf-controls-overlay .control-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.4);
    transform: scale(1.1);
}

.pdf-controls-overlay .control-btn:active {
    background: rgba(255, 255, 255, 0.3);
    transform: scale(0.95);
}

.pdf-controls-overlay .control-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.pdf-controls-overlay .control-icon {
    width: 12px;
    height: 12px;
    stroke: currentColor;
    stroke-width: 2;
    fill: none;
    stroke-linecap: round;
    stroke-linejoin: round;
}

.pdf-controls-overlay .zoom-display {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.1rem 0.3rem;
    border-radius: 3px;
    font-weight: 600;
    min-width: 40px;
    text-align: center;
    color: white;
    font-size: 0.7rem;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

#x-density-right {
    grid-row: 1 / 2; grid-column: 6 / 7;
    background-color: #ffd700;
    position: relative;
}

#reconstructed {
    grid-row: 2 / 3; grid-column: 6 / 7;
    background-color: #ffffe0;
    position: relative;
    overflow: auto;
}

#y-density-right {
    grid-row: 2 / 3; grid-column: 7 / 8;
    background-color: #f0e68c;
    writing-mode: vertical-rl;
    transform: rotate(180deg);
    position: relative;
}

/* --- BLUE HUES - Annotations and Toggles --- */
#annotations {
    grid-row: 2 / 3; grid-column: 3 / 5;
    background-color: #00ffff;
    overflow-y: auto;
    padding: 0.5rem;
    font-size: 0.8rem;
}

#toggles {
    grid-row: 3 / 5; grid-column: 3 / 5;
    background-color: #007fff;
    padding: 0.5rem;
    overflow-y: auto;
    align-items: flex-start;
    justify-content: flex-start;
}

.label-toggles-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
}

.toggle-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.toggle-btn {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.75rem;
    transition: all 0.2s;
}

.toggle-btn:hover {
    background: rgba(255, 255, 255, 0.3);
}

.label-checkboxes {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    overflow-y: auto;
}

.label-checkbox-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
}

.label-checkbox-item input[type="checkbox"] {
    cursor: pointer;
}

.label-checkbox-item label {
    cursor: pointer;
    color: white;
    font-size: 0.8rem;
    flex: 1;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.label-color-swatch {
    width: 12px;
    height: 12px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 2px;
    display: inline-block;
}

/* --- PURPLE HUES - Options --- */
#options {
    grid-row: 3 / 4; grid-column: 1 / 3;
    background-color: #8a2be2;
    padding: 0.5rem;
    overflow-y: auto;
    align-items: flex-start; /* Override .box centering */
    justify-content: flex-start; /* Override .box centering */
}

/* PDF Controls */
.pdf-controls {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    color: white;
}

.control-group {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    font-size: 0.8rem;
}

.control-group label {
    font-weight: 600;
    min-width: 40px;
}

.control-btn {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.2s;
}

.control-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    border-color: rgba(255, 255, 255, 0.5);
}

.control-btn:active {
    background: rgba(255, 255, 255, 0.4);
}

.control-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.zoom-display, .page-display, .file-display {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    font-weight: 600;
    min-width: 50px;
    text-align: center;
}

.file-display {
    min-width: 80px;
    font-size: 0.7rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

#options-right {
    grid-row: 3 / 4; grid-column: 6 / 8;
    background-color: #9932cc;
    padding: 0.5rem;
    overflow-y: auto;
}

/* --- ORANGE HUES - Logs --- */
#log {
    grid-row: 4 / 5; grid-column: 1 / 3;
    background-color: #ffa500;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
    position: relative; /* Anchor for absolutely positioned button */
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Override .box centering */
    justify-content: flex-start; /* Override .box centering */
}

.log-scroll-container {
    flex: 1;
    width: 100%;
    overflow-y: auto;
    padding: 0.5rem;
}

.log-content {
    direction: ltr; /* Left-to-right text direction */
    text-align: left;
}

#log-right {
    grid-row: 4 / 5; grid-column: 6 / 8;
    background-color: #ff8c00;
    padding: 0.5rem;
    overflow-y: auto;
    font-family: 'Courier New', monospace;
    font-size: 0.8rem;
}

/* Log content styling - merged with above */

.log-entry {
    text-align: left;
    margin-bottom: 0.25rem;
    white-space: pre-wrap; /* Preserve formatting */
}

/* Options title - positioned near the toggle */
.options-title {
    color: white;
    font-size: 0.9rem;
    font-weight: 600;
    position: absolute;
    top: 8px;
    right: 35px; /* Just to the left of the toggle button */
    pointer-events: none; /* Don't block clicks */
}

/* Collapsible options button - positioned in upper right */
.options-toggle {
    position: absolute;
    top: 5px;
    right: 5px;
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 0.15rem 0.4rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.75rem;
    z-index: 10;
    line-height: 1.2;
    min-width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.options-toggle:hover {
    background: rgba(255, 255, 255, 0.3);
}

/* Collapsed options panel - show a thin line */
.options-collapsed {
    height: 25px !important;
    min-height: 25px !important;
    max-height: 25px !important;
    overflow: hidden;
    transition: all 0.3s ease;
}

.options-collapsed .pdf-controls {
    display: none;
}

/* Expanded log panel */
.log-expanded {
    grid-row: 3 / 5 !important;
}

#options {
    transition: max-height 0.3s ease;
    overflow: hidden;
    flex-direction: column;
}

/* Copy log button - always in bottom right of log box */
.log-copy-button {
    position: absolute;
    bottom: 25px;
    right: 5px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.8rem;
    z-index: 100;
    opacity: 0.6;
    transition: opacity 0.2s;
}

.log-copy-button:hover {
    opacity: 1;
    background: rgba(0, 0, 0, 0.7);
}

/* --- CENTER DIVIDER --- */
.center-divider {
    grid-row: 1 / 5; grid-column: 5 / 6;
    background-color: #555;
}

/* PDF Canvas Styling */
.pdf-canvas-container {
    position: relative;
    background: rgb(214, 153, 218);
    display: flex;
    flex-direction: column;
    align-items: flex-start; /* Left-align content for proper panning */
    padding: 5px;
    min-height: 200vh; /* Ensure content is much taller than viewport for scrolling */
    /* Removed width: 100% to allow container to grow wider than parent for zoom/pan */
}

#pdf-canvas {
    display: block;
    max-width: 100%;
    height: auto;
    margin: 0;
    box-shadow: none;
    border-radius: 0;
    will-change: transform; /* Optimize for scaling */
}

/* (removed wrapper styling per request) */

/* Annotation Overlays */
.annotation-overlay {
    position: absolute;
    border: 1px solid #ff6b6b;
    background: rgba(255, 107, 107, 0.1);
    pointer-events: auto;
    cursor: pointer;
    transition: all 0.2s ease;
}

.annotation-overlay:hover {
    background: rgba(255, 107, 107, 0.3);
    border-color: #ff5252;
    border-width: 1.5px;
    transform: scale(1.02);
    z-index: 1000;
}

.annotation-overlay.selected {
    border-color: #2196F3;
    border-width: 1.5px;
    background: rgba(33, 150, 243, 0.2);
    transform: scale(1.02);
    z-index: 1000;
}

.page-overlay-container {
    pointer-events: none;
}

.page-overlay-container .annotation-overlay {
    pointer-events: auto;
}

/* Connection lines from PDF to annotations */
.connection-line {
    position: absolute;
    background: #2196F3;
    pointer-events: none;
    z-index: 10;
    opacity: 0.6;
    transition: opacity 0.2s ease;
}

.connection-line:hover {
    opacity: 1;
}

.connection-line.selected {
    background: #ff6b6b;
    opacity: 1;
}

/* Annotation List */
.annotation-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.annotation-item {
    padding: 0.5rem;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.2s ease;
    background: rgba(255, 255, 255, 0.8);
}

.annotation-item:hover {
    background: rgba(255, 255, 255, 0.9);
}

.annotation-item.selected {
    background: #e3f2fd;
    border-color: #2196F3;
}

.annotation-type {
    font-weight: bold;
    color: #666;
    margin-bottom: 0.25rem;
}

.annotation-content {
    color: #333;
    word-break: break-word;
}

/* Not Implemented Placeholders */
.not-implemented {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.8);
    color: #666;
    font-size: 0.8rem;
    font-style: italic;
    text-align: center;
    padding: 0.5rem;
    border: 1px dashed #ccc;
    border-radius: 4px;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    .app-container {
        grid-template-columns: 40px 1fr 40px 40px 2px 1fr 40px;
    }
}

@media (max-width: 768px) {
    .app-container {
        grid-template-columns: 30px 1fr 30px 30px 2px 1fr 30px;
        grid-template-rows: 30px 1fr 60px 80px;
    }
}
</file>

<file path="src/johnny5/web/static/app.js">
// Johnny5 Web Viewer JavaScript

// Helper function to get grid total height
function getGridTotalHeight(container) {
    const grid = document.getElementById('pdf-grid');
    return grid ? (grid.offsetHeight || grid.clientHeight) : container.scrollHeight;
}

class Johnny5Viewer {
    constructor() {
        this.pdfDoc = null;
        this.currentPage = 1;
        this.totalPages = 0;
        this.scale = 1.0;
        this.canvas = null; // Will be created dynamically for each page
        this.ctx = null;
        this.websocket = null;
        this.structureData = null;
        this.densityData = null;
        this.allStructureData = {}; // Store structure data for all pages
        this.allDensityData = {}; // Store density data for all pages
        this.activeLabels = new Set(); // Currently enabled labels
        this.allLabels = []; // All available labels from document
        this.labelColors = {}; // Color scheme for each label type
        
        // Initialize density charts module
        this.densityCharts = new DensityCharts(this);
        
        // Redirect console output to log window
        this.redirectConsoleToLog();
        
        this.init();
    }
    
    redirectConsoleToLog() {
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = (...args) => {
            originalLog.apply(console, args);
            this.addLogEntry('left', args.join(' '), 'debug');
        };
        
        console.error = (...args) => {
            originalError.apply(console, args);
            this.addLogEntry('left', args.join(' '), 'error');
        };
        
        console.warn = (...args) => {
            originalWarn.apply(console, args);
            this.addLogEntry('left', args.join(' '), 'warning');
        };
    }

    async init() {
        console.log('Johnny5 Web Viewer initializing...');
        
        // Initialize PDF.js
        await this.initPDFJS();
        
        // Setup event listeners
        this.setupEventListeners();
        
        // Connect to WebSocket for logs
        this.connectWebSocket();
        
        // Auto-load test PDF
        await this.loadTestPDF();
        
        console.log('Johnny5 Web Viewer initialized');
    }

    async initPDFJS() {
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // Set default scale to 1.0; fitWidth() will calculate the correct initial scale
        this.scale = 1.0;
    }

    setupEventListeners() {
        // Image panel indicators
        document.getElementById('indicator-i').addEventListener('click', () => this.toggleImagePanel('i'));
        document.getElementById('indicator-d').addEventListener('click', () => this.toggleImagePanel('d'));
        document.getElementById('indicator-e').addEventListener('click', () => this.toggleImagePanel('e'));
        document.getElementById('indicator-r').addEventListener('click', () => this.toggleImagePanel('r'));
        
        // PDF file input
        const fileInput = document.getElementById('pdf-file-input');
        const loadBtn = document.getElementById('load-pdf-btn');
        const fileNameDisplay = document.getElementById('current-file-name');
        
        loadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                fileNameDisplay.textContent = file.name;
                this.addLogEntry('left', `Loading PDF: ${file.name}`);
                this.loadNewPDF(file);
            }
        });
        
        // PDF controls (minimal overlay)
        document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
        document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());
        document.getElementById('fit-width').addEventListener('click', () => this.fitWidth());
        document.getElementById('fit-height').addEventListener('click', () => this.fitHeight());
        
        // Options toggle
        document.getElementById('options-toggle').addEventListener('click', () => this.toggleOptions());
        
        // Log copy button
        document.getElementById('log-copy-button').addEventListener('click', () => this.copyLog());
        
        // Page count overlay updates on scroll
        const scroller = document.getElementById('pdf-scroller');
        scroller.addEventListener('scroll', () => {
            this.updateCurrentPage();
        });
        
        // Left ruler scroll sync handled in drawLeftPanelRuler()
        
        // Trackpad/wheel zoom support
        this.setupTrackpadSupport();
        
        // Scroll synchronization (to be implemented)
        
        // Label toggle controls
        document.getElementById('select-all-labels').addEventListener('click', () => this.selectAllLabels());
        document.getElementById('deselect-all-labels').addEventListener('click', () => this.deselectAllLabels());
    }

    connectWebSocket() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/logs`;
        
        this.websocket = new WebSocket(wsUrl);
        
        this.websocket.onopen = () => {
            console.log('WebSocket connected');
            this.addLogEntry('left', 'WebSocket connected', 'info');
        };
        
        this.websocket.onmessage = (event) => {
            try {
                const logEntry = JSON.parse(event.data);
                this.addLogEntry(logEntry.pane, logEntry.message, logEntry.level.toLowerCase());
            } catch (e) {
                console.error('Failed to parse log entry:', e);
            }
        };
        
        this.websocket.onclose = () => {
            console.log('WebSocket disconnected');
            this.addLogEntry('left', 'WebSocket disconnected', 'warning');
        };
        
        this.websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.addLogEntry('left', 'WebSocket error', 'error');
        };
    }

    async loadPDF() {
        try {
            console.log('Loading PDF...');
            this.addLogEntry('left', 'Loading PDF...', 'info');
            
            const loadingTask = pdfjsLib.getDocument('/api/pdf');
            this.pdfDoc = await loadingTask.promise;
            this.totalPages = this.pdfDoc.numPages;
            
            console.log(`PDF loaded: ${this.totalPages} pages`);
            this.addLogEntry('left', `PDF loaded: ${this.totalPages} pages`, 'info');
            
            // Update UI
            this.updatePageInfo();
            this.updateNavigationButtons();
            
            // Render first page
            await this.renderPage(this.currentPage);
            
        } catch (error) {
            console.error('Failed to load PDF:', error);
            this.addLogEntry('left', `Failed to load PDF: ${error.message}`, 'error');
        }
    }

    async renderPage(pageNum) {
        // This method is deprecated - using renderAllPages() instead
        // Keeping for compatibility but redirecting to renderAllPages
        console.log('renderPage() called but using renderAllPages() instead');
        await this.renderAllPages();
    }

    async loadTestPDF() {
        try {
            console.log('Auto-loading test PDF...');
            this.addLogEntry('left', 'Auto-loading test PDF: 02-split_table.pdf');
            
            // Load test PDF from server - the server is already serving the multi-page PDF
            const loadingTask = pdfjsLib.getDocument('/api/pdf');
            this.pdfDoc = await loadingTask.promise;
            this.totalPages = this.pdfDoc.numPages;
            this.currentPage = 1;
            
            console.log(`Test PDF loaded successfully. Pages: ${this.totalPages}`);
            this.addLogEntry('left', `Test PDF loaded successfully. Pages: ${this.totalPages}`);
            
            // Fit to width (this will set the scale and render all pages)
            await this.fitWidth();
            
            // Load structure and density data for all pages
            await this.loadAllPageData();
            
        } catch (error) {
            console.error('Error loading test PDF:', error);
            this.addLogEntry('left', `Error loading test PDF: ${error.message}`, 'error');
        }
    }
    
    async loadPageData() {
        // This method is deprecated - using loadAllPageData() instead
        // Keeping for compatibility but should not be used
        console.log('loadPageData() called but using loadAllPageData() instead');
        await this.loadAllPageData();
    }
    
    async loadAllPageData() {
        try {
            let loadedCount = 0;
            // Load structure and density data for all pages
            for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                try {
                    const structureResponse = await fetch(`/api/structure/${pageNum}`);
                    const densityResponse = await fetch(`/api/density/${pageNum}`);
                    
                    if (structureResponse.ok) {
                        const structureData = await structureResponse.json();
                        this.allStructureData[pageNum] = structureData;
                        loadedCount++;
                    }
                    
                    if (densityResponse.ok) {
                        const densityData = await densityResponse.json();
                        this.allDensityData[pageNum] = densityData;
                    }
                } catch (error) {
                    console.log(`Failed to load data for page ${pageNum}: ${error.message}`);
                }
            }
            
            if (loadedCount > 0) {
                this.addLogEntry('left', `Loaded structure data for ${loadedCount} pages`);
                
                // After loading all data, extract unique labels and build toggle UI
                this.extractUniqueLabels();
                this.renderLabelToggles();
                
                // Render annotations for all pages
                this.renderAllAnnotations();
                
                // Replace y-density with left-side PDF-coordinate ruler instead of charts
                await Promise.resolve();
            } else {
                this.addLogEntry('left', 'No structure data available. Run disassemble command first.', 'warning');
            }
        } catch (error) {
            this.addLogEntry('left', `Failed to load page data: ${error.message}`, 'error');
        }
    }

    renderAnnotations() {
        if (!this.structureData || !this.structureData.page) return;
        
        const overlayContainer = document.getElementById('overlay-container');
        const annotationList = document.getElementById('annotation-list');
        
        // Clear existing annotations
        overlayContainer.innerHTML = '';
        annotationList.innerHTML = '';
        this.clearConnectionLines();
        
        const page = this.structureData.page;
        const canvasRect = this.canvas.getBoundingClientRect();
        const canvasContainerRect = this.canvas.parentElement.getBoundingClientRect();
        
        // Calculate scale factor for overlay positioning
        const scaleX = canvasRect.width / page.width;
        const scaleY = canvasRect.height / page.height;
        
        page.elements.forEach((element, index) => {
            if (!element.bbox || element.bbox.length !== 4) return;
            
            const [x0, y0, x1, y1] = element.bbox;
            
            // Create overlay element
            const overlay = document.createElement('div');
            overlay.className = 'annotation-overlay';
            overlay.style.left = `${x0 * scaleX}px`;
            overlay.style.top = `${y0 * scaleY}px`;
            overlay.style.width = `${(x1 - x0) * scaleX}px`;
            overlay.style.height = `${(y1 - y0) * scaleY}px`;
            overlay.dataset.index = index;
            
            overlay.addEventListener('click', () => this.selectAnnotation(index));
            
            overlayContainer.appendChild(overlay);
            
            // Create annotation list item
            const listItem = document.createElement('div');
            listItem.className = 'annotation-item';
            listItem.dataset.index = index;
            
            const typeDiv = document.createElement('div');
            typeDiv.className = 'annotation-type';
            typeDiv.textContent = element.type || 'Unknown';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'annotation-content';
            contentDiv.textContent = element.content || 'No content';
            
            listItem.appendChild(typeDiv);
            listItem.appendChild(contentDiv);
            listItem.addEventListener('click', () => this.selectAnnotation(index));
            
            annotationList.appendChild(listItem);
            
            // Create connection line
            this.createConnectionLine(overlay, listItem, index);
        });
        
        // Show annotations gutter if we have elements
        if (page.elements.length > 0) {
            document.querySelector('.annotations-gutter .not-implemented').style.display = 'none';
            document.querySelector('.annotations-gutter h4').style.display = 'block';
            annotationList.style.display = 'block';
        }
    }
    
    createConnectionLine(overlay, listItem, index) {
        const connectionLine = document.createElement('div');
        connectionLine.className = 'connection-line';
        connectionLine.dataset.index = index;
        
        // Position the connection line
        this.updateConnectionLinePosition(connectionLine, overlay, listItem);
        
        // Add to overlay container
        document.getElementById('overlay-container').appendChild(connectionLine);
        
        // Update position on scroll and resize
        const updatePosition = () => this.updateConnectionLinePosition(connectionLine, overlay, listItem);
        window.addEventListener('scroll', updatePosition);
        window.addEventListener('resize', updatePosition);
    }
    
    updateConnectionLinePosition(connectionLine, overlay, listItem) {
        const overlayRect = overlay.getBoundingClientRect();
        const listItemRect = listItem.getBoundingClientRect();
        const containerRect = document.getElementById('overlay-container').getBoundingClientRect();
        
        // Calculate positions relative to the overlay container
        const startX = overlayRect.right - containerRect.left;
        const startY = overlayRect.top + overlayRect.height / 2 - containerRect.top;
        const endX = listItemRect.left - containerRect.left;
        const endY = listItemRect.top + listItemRect.height / 2 - containerRect.top;
        
        // Calculate line properties
        const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
        
        // Position and style the line
        connectionLine.style.left = `${startX}px`;
        connectionLine.style.top = `${startY}px`;
        connectionLine.style.width = `${length}px`;
        connectionLine.style.height = '2px';
        connectionLine.style.transformOrigin = '0 0';
        connectionLine.style.transform = `rotate(${angle}deg)`;
    }
    
    clearConnectionLines() {
        const connectionLines = document.querySelectorAll('.connection-line');
        connectionLines.forEach(line => line.remove());
    }

    selectAnnotation(index, pageNum = null) {
        // Remove previous selection
        document.querySelectorAll('.annotation-overlay.selected, .annotation-item.selected, .connection-line.selected').forEach(el => {
            el.classList.remove('selected');
        });
        
        // Add selection to clicked annotation and its connection line
        const selector = pageNum ? `[data-index="${index}"][data-page="${pageNum}"]` : `[data-index="${index}"]`;
        document.querySelectorAll(selector).forEach(el => {
            el.classList.add('selected');
        });
    }

    // Density chart rendering moved to DensityCharts module

    async previousPage() {
        if (this.currentPage > 1) {
            this.currentPage--;
            await this.renderPage(this.currentPage);
            this.updatePageInfo();
            this.updateNavigationButtons();
        }
    }

    async nextPage() {
        if (this.currentPage < this.totalPages) {
            this.currentPage++;
            await this.renderPage(this.currentPage);
            this.updatePageInfo();
            this.updateNavigationButtons();
        }
    }

    zoomIn() {
        this.scale = Math.min(this.scale * 1.2, 20.0); // Allow zoom up to 20x
        this.renderAllPages().then(async () => {
            await this.densityCharts.renderStaticCharts();
        });
        this.updateZoomInfo();
    }

    zoomOut() {
        this.scale = Math.max(this.scale / 1.2, 0.1);
        this.renderAllPages().then(async () => {
            await this.densityCharts.renderStaticCharts();
        });
        this.updateZoomInfo();
    }
    
    async renderAllPages() {
        if (!this.pdfDoc) {
            console.error('No PDF document loaded');
            return;
        }
        
        console.log(`Starting to render ${this.totalPages} pages at scale ${this.scale}`);
        this.addLogEntry('left', `Rendering ${this.totalPages} pages...`);
        
        const container = document.getElementById('pdf-canvas-container');
        if (!container) {
            console.error('PDF canvas container not found');
            return;
        }
        
        container.innerHTML = ''; // Clear existing content
        
        // Render pages sequentially to preserve page order
        // (This is important for proper visual ordering)
        try {
            this.pageViewportHeights = {};
            this.pageViewportWidths = {};
            for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
                try {
                    await this.renderPageToContainer(pageNum, container);
                } catch (error) {
                    console.error(`Failed to render page ${pageNum}:`, error);
                    this.addLogEntry('left', `Failed to render page ${pageNum}: ${error.message}`, 'error');
                }
            }
            
            console.log(`Successfully rendered all ${this.totalPages} pages`);
            this.addLogEntry('left', `Successfully rendered ${this.totalPages} pages`);
            
            // Update the page counter after initial render
            this.updateCurrentPage();

            // Lock panel height to scroller viewport before drawing
            const scroller = document.getElementById('pdf-scroller');
            const yPanel = document.getElementById('y-density');
            if (yPanel && scroller) {
                yPanel.style.height = scroller.clientHeight + 'px';
            }

            // Draw verification grid overlay aligned to PDF scroll space
            await this.drawPdfGrid();
            // Draw left ruler inside the y-density panel aligned to PDF coordinates
            await this.drawLeftPanelRuler();
        } catch (error) {
            console.error('Error rendering pages:', error);
            this.addLogEntry('left', `Error rendering pages: ${error.message}`, 'error');
        }
    }
    
    async renderPageToContainer(pageNum, container) {
        if (!container) {
            throw new Error('Container is null');
        }
        
        const page = await this.pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: this.scale });
        
        console.log(`Rendering page ${pageNum}: ${viewport.width}x${viewport.height}`);
        
        // Create a page wrapper div for better spacing and debugging
        const pageWrapper = document.createElement('div');
        pageWrapper.className = 'pdf-page-wrapper';
        pageWrapper.dataset.pageNum = pageNum;
        pageWrapper.style.marginBottom = '5px';
        pageWrapper.style.position = 'relative';
        
        // Create canvas with high-DPI support
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        if (!ctx) {
            throw new Error('Failed to get 2d context');
        }
        
        // Get the screen's pixel ratio for high-DPI rendering
        const outputScale = window.devicePixelRatio || 1;
        
        // Set CANVAS PIXEL size (backing store) - multiplied by devicePixelRatio for crisp rendering
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        
        // Set CANVAS DISPLAY size (CSS) - explicit pixel sizes allow zoom beyond container width
        canvas.style.width = Math.floor(viewport.width) + 'px';
        canvas.style.height = Math.floor(viewport.height) + 'px';
        canvas.style.display = 'block';
        canvas.style.margin = '0';
        canvas.style.boxShadow = 'none';
        canvas.style.borderRadius = '0';
        // Removed maxWidth constraint to allow zooming beyond container width
        
        // Create the transform for high-DPI rendering
        const transform = outputScale !== 1
            ? [outputScale, 0, 0, outputScale, 0, 0]
            : null;
        
        // Render page with high-DPI transform
        const renderContext = {
            canvasContext: ctx,
            viewport: viewport,
            transform: transform
        };
        
        await page.render(renderContext).promise;
        this.pageViewportHeights[pageNum] = viewport.height; // CSS px at current scale
        this.pageViewportWidths[pageNum] = viewport.width;
        pageWrapper.appendChild(canvas);
        
        if (container && typeof container.appendChild === 'function') {
            container.appendChild(pageWrapper);
        } else {
            throw new Error('Container.appendChild is not a function or container is null');
        }
        
        console.log(`Page ${pageNum} rendered successfully at ${Math.round(this.scale * 100)}% (devicePixelRatio: ${outputScale})`);
    }
    
    async fitWidth() {
        if (!this.pdfDoc) return;
        
        // Wait for container to have dimensions
        await new Promise(resolve => {
            const checkContainer = () => {
                const container = document.getElementById('pdf-viewer');
                if (container && container.clientWidth > 0) {
                    resolve();
                } else {
                    requestAnimationFrame(checkContainer);
                }
            };
            checkContainer();
        });
        
        const page = await this.pdfDoc.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });
        const container = document.getElementById('pdf-viewer');
        // Use 10px padding (5px left/right) from .pdf-canvas-container
        const containerWidth = container.clientWidth - 10;
        
        // Calculate scale for width
        this.scale = containerWidth / viewport.width;
        
        console.log(`Fit width: container=${containerWidth}, page=${viewport.width}, scale=${this.scale}`);
        this.addLogEntry('left', `Fitting to width: ${Math.round(this.scale * 100)}%`);
        
        await this.renderAllPages(); // Await the render
        this.updateZoomInfo();
    }
    
    async fitHeight() {
        if (!this.pdfDoc) return;

        const page = await this.pdfDoc.getPage(1);
        const viewport = page.getViewport({ scale: 1.0 });
        const container = document.getElementById('pdf-viewer');

        // container.clientHeight - 10px (5px top + 5px bottom padding)
        const containerHeight = container.clientHeight - 10;

        // Calculate scale for height
        this.scale = containerHeight / viewport.height;
        
        console.log(`Fit height: container=${containerHeight}, page=${viewport.height}, scale=${this.scale}`);
        this.addLogEntry('left', `Fitting to height: ${Math.round(this.scale * 100)}%`);
        
        await this.renderAllPages();
        this.updateZoomInfo();
    }

    updatePageInfo() {
        document.getElementById('page-info').textContent = `Page ${this.currentPage} of ${this.totalPages}`;
    }

    updateNavigationButtons() {
        document.getElementById('prev-page').disabled = this.currentPage <= 1;
        document.getElementById('next-page').disabled = this.currentPage >= this.totalPages;
    }

    updateZoomInfo() {
        document.getElementById('zoom-level').textContent = `${Math.round(this.scale * 100)}%`;
    }

    async drawPdfGrid() {
        const scroller = document.getElementById('pdf-scroller');
        const container = document.getElementById('pdf-canvas-container');
        if (!scroller || !container || !this.pdfDoc) return;
    
        let gridCanvas = document.getElementById('pdf-grid');
        if (!gridCanvas) {
            gridCanvas = document.createElement('canvas');
            gridCanvas.id = 'pdf-grid';
            scroller.appendChild(gridCanvas);
        }
    
        const width = container.scrollWidth;
        const height = container.scrollHeight || container.offsetHeight;
        const dpr = window.devicePixelRatio || 1;
    
        gridCanvas.style.width = `${width}px`;
        gridCanvas.style.height = `${height}px`;
        gridCanvas.width = Math.floor(width * dpr);
        gridCanvas.height = Math.floor(height * dpr);
    
        const ctx = gridCanvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
    
        const padTop = parseFloat(getComputedStyle(container).paddingTop) || 0;
        const padLeft = parseFloat(getComputedStyle(container).paddingLeft) || 0;
    
        const pageWrappers = container.querySelectorAll('.pdf-page-wrapper');
        const pdfStep = 15;
    
        for (const wrapper of pageWrappers) {
            const pageNum = +wrapper.dataset.pageNum;
            const pageTop = wrapper.offsetTop;
            const page = await this.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: this.scale });
    
            // PDF-space bounds
            const [pageWidth, pageHeight] = page.view.slice(2); // PDF user-space size

            // Map PDF (0,0), (W,0), (0,H) to viewport coordinates
            const [x0, y0] = viewport.convertToViewportPoint(0, 0);
            const [x1, y1] = viewport.convertToViewportPoint(pageWidth, 0);
            const [x2, y2] = viewport.convertToViewportPoint(0, pageHeight);
                
            // Translate into scroll-space: wrapper offset + container padding
            const offsetX = padLeft;
            const offsetY = padTop + pageTop;
    
            ctx.strokeStyle = 'rgba(220,0,0,0.9)';
            ctx.lineWidth = 1.5;
            
            // Draw X-axis
            ctx.beginPath();
            ctx.moveTo(offsetX + x0, offsetY + y0);
            ctx.lineTo(offsetX + x1, offsetY + y1);
            ctx.stroke();
    
            // Draw Y-axis
            ctx.beginPath();
            ctx.moveTo(offsetX + x0, offsetY + y0);
            ctx.lineTo(offsetX + x2, offsetY + y2);
            ctx.stroke();

            // ---------- origin line ----------
            const [xStep, yStep] = viewport.convertToViewportPoint(pdfStep, pdfStep);
            
            ctx.beginPath();
            ctx.moveTo(offsetX + x0, offsetY + y0);
            ctx.lineTo(offsetX + xStep, offsetY + yStep);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 0.5;
            // ---- horizontal lines (constant yPDF) ----
            for (let yPdf = 0; yPdf <= pageHeight; yPdf += pdfStep) {
                // Skip the origin row - the red X-axis lives here
                if (yPdf === 0) continue;
                const [x0, y0] = viewport.convertToViewportPoint(0, yPdf);
                const [x1, y1] = viewport.convertToViewportPoint(pageWidth, yPdf);
                // Snap to device pixel for crispness
                const sx0 = Math.floor(offsetX + x0) + 0.5;
                const sy0 = Math.floor(offsetY + y0) + 0.5;
                const sx1 = Math.floor(offsetX + x1) + 0.5;
                const sy1 = Math.floor(offsetY + y1) + 0.5;
                ctx.beginPath();
                ctx.moveTo(sx0, sy0);
                ctx.lineTo(sx1, sy1);
                ctx.stroke();
            }
        
            // ---- vertical lines (constant xPDF) ----
            for (let xPdf = 0; xPdf <= pageWidth; xPdf += pdfStep) {
                // Skip the origin column - the red Y-axis lives here
                if (xPdf === 0) continue;
                const [x0, y0] = viewport.convertToViewportPoint(xPdf, 0);
                const [x1, y1] = viewport.convertToViewportPoint(xPdf, pageHeight);
                // Snap to device pixel for crispness
                const sx0 = Math.floor(offsetX + x0) + 0.5;
                const sy0 = Math.floor(offsetY + y0) + 0.5;
                const sx1 = Math.floor(offsetX + x1) + 0.5;
                const sy1 = Math.floor(offsetY + y1) + 0.5;
                ctx.beginPath();
                ctx.moveTo(sx0, sy0);
                ctx.lineTo(sx1, sy1);
                ctx.stroke();
            }
        }
    }
    

    async drawLeftPanelRuler() {
        const yPanel   = document.getElementById('y-density');
        const scroller = document.getElementById('pdf-scroller');
        const container = document.getElementById('pdf-canvas-container');
        if (!yPanel || !scroller || !container || !this.pdfDoc) return;
      
        // Lock the panel’s visible height to the scroller viewport (border-box)
        yPanel.style.height = scroller.clientHeight + 'px';
      
        // TOTAL height must equal the scroller's scrollable height
        const totalHeight = container.scrollHeight;
      
        // Build one canvas spanning full scroll height
        yPanel.innerHTML = '';
        const canvas = document.createElement('canvas');
        yPanel.appendChild(canvas);
      
        const panelWidth = Math.max(36, yPanel.clientWidth || 36);
        const dpr = window.devicePixelRatio || 1;
      
        canvas.style.width  = `${panelWidth}px`;
        canvas.style.height = `${totalHeight}px`;
        canvas.width  = Math.floor(panelWidth * dpr);
        canvas.height = Math.floor(totalHeight * dpr);

        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, panelWidth, totalHeight);
      
        const pdfStep = 15; // PDF units
        const padTop = parseFloat(getComputedStyle(container).paddingTop) || 0;
      
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1;
      
        const pages = container.querySelectorAll('.pdf-page-wrapper');
        for (const wrapper of pages) {
          const pageNum = +wrapper.dataset.pageNum;
          const pageTop = wrapper.offsetTop; // scroll-space offset of the page
          const page = await this.pdfDoc.getPage(pageNum);
          const viewport = page.getViewport({ scale: this.scale });
      
          // Proper width/height in PDF units (don’t assume origin==0)
          const [x0, y0, x1, y1] = page.view;
          const pageHeight = (y1 - y0);
      
          for (let yPdf = 0; yPdf <= pageHeight + 1e-6; yPdf += pdfStep) {
            // SAME mapping as grid: no flip, no tricks
            const [, yLocal] = viewport.convertToViewportPoint(0, yPdf);
            const y = padTop + pageTop + yLocal;      
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(panelWidth, y);
            ctx.stroke();
          }
        }
      
        // One scroll handler, no duplicates
        if (!this._rulerScrollHandler) {
          this._rulerScrollHandler = () => { yPanel.scrollTop = scroller.scrollTop; };
          scroller.addEventListener('scroll', this._rulerScrollHandler);
        }
        yPanel.scrollTop = scroller.scrollTop;
      }
      
      

      
    


    addLogEntry(pane, message, level = 'info') {
        const logContent = document.getElementById(`${pane}-log-content`);
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${level}`;
        
        const timestamp = new Date().toLocaleTimeString();
        logEntry.textContent = `[${timestamp}] ${message}`;
        
        logContent.appendChild(logEntry);
        logContent.scrollTop = logContent.scrollHeight;
        
        // Keep only last 100 entries
        while (logContent.children.length > 100) {
            logContent.removeChild(logContent.firstChild);
        }
    }

    clearLog(pane) {
        const logContent = document.getElementById(`${pane}-log-content`);
        logContent.innerHTML = '<div class="log-entry">Log cleared</div>';
    }

    // File input controls will be implemented later in the options panel
    
    toggleImagePanel(type) {
        const panel = document.getElementById(`indicator-${type}`);
        const isActive = panel.classList.contains('active');
        
        // Toggle active state
        if (isActive) {
            panel.classList.remove('active');
            this.addLogEntry('left', `Image panel ${type} deactivated`);
        } else {
            panel.classList.add('active');
            this.addLogEntry('left', `Image panel ${type} activated`);
        }
    }
    
    setupTrackpadSupport() {
        const pdfScroller = document.getElementById('pdf-scroller');
        let lastWheelTime = 0;
        let isZooming = false;
        
        pdfScroller.addEventListener('wheel', (e) => {
            // Check if this is a zoom gesture (Ctrl/Cmd + wheel)
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const now = Date.now();
                if (now - lastWheelTime < 100) return; // Throttle zoom
                lastWheelTime = now;
                
                if (e.deltaY < 0) {
                    this.zoomIn();
                } else {
                    this.zoomOut();
                }
            } else {
                // Regular scrolling - allow smooth scrolling
                // Don't prevent default to allow native smooth scrolling
            }
        }, { passive: false });
        
        // Add keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const pdfScroller = document.getElementById('pdf-scroller');
            switch(e.key) {
                case 'ArrowUp':
                case 'PageUp':
                    e.preventDefault();
                    pdfScroller.scrollBy({ top: -pdfScroller.clientHeight * 0.8, behavior: 'smooth' });
                    break;
                case 'ArrowDown':
                case 'PageDown':
                    e.preventDefault();
                    pdfScroller.scrollBy({ top: pdfScroller.clientHeight * 0.8, behavior: 'smooth' });
                    break;
                case 'Home':
                    e.preventDefault();
                    pdfScroller.scrollTo({ top: 0, behavior: 'smooth' });
                    break;
                case 'End':
                    e.preventDefault();
                    pdfScroller.scrollTo({ top: pdfScroller.scrollHeight, behavior: 'smooth' });
                    break;
            }
        });
    }
    
    async loadNewPDF(file) {
        try {
            this.addLogEntry('left', 'Loading new PDF file...');
            
            // Create object URL for the file
            const fileUrl = URL.createObjectURL(file);
            
            // Load PDF with PDF.js
            const loadingTask = pdfjsLib.getDocument(fileUrl);
            this.pdfDoc = await loadingTask.promise;
            this.totalPages = this.pdfDoc.numPages;
            this.currentPage = 1;
            
            this.addLogEntry('left', `PDF loaded successfully. Pages: ${this.totalPages}`);
            
            // Render all pages
            await this.renderAllPages();
            
            // Load structure and density data for the new PDF
            await this.loadAllPageData();
            
            // Clean up object URL
            URL.revokeObjectURL(fileUrl);
            
        } catch (error) {
            this.addLogEntry('left', `Error loading PDF: ${error.message}`, 'error');
            console.error('Error loading PDF:', error);
        }
    }

    updateCurrentPage() {
        const scroller = document.getElementById('pdf-scroller');
        const pageWrappers = document.querySelectorAll('.pdf-page-wrapper');
        const overlay = document.getElementById('page-count-overlay');
        
        if (!scroller || pageWrappers.length === 0 || !overlay) return;

        // Get the vertical center of the scroller's visible area
        const scrollerCenter = scroller.scrollTop + (scroller.clientHeight / 2);

        let closestPage = 1;
        let minDistance = Infinity;

        pageWrappers.forEach(wrapper => {
            const pageTop = wrapper.offsetTop;
            const pageCenter = pageTop + (wrapper.offsetHeight / 2);
            
            // Find which page's center is closest to the scroller's center
            const distance = Math.abs(pageCenter - scrollerCenter);

            if (distance < minDistance) {
                minDistance = distance;
                closestPage = parseInt(wrapper.dataset.pageNum, 10);
            }
        });

        // Only update if page changed
        if (this.currentPage !== closestPage) {
            this.currentPage = closestPage;
            overlay.textContent = `${this.currentPage} / ${this.totalPages}`;
            // Update dynamic X-axis charts for the new page
            this.densityCharts.updateDynamicCharts();
        }
    }

    toggleOptions() {
        const optionsPanel = document.getElementById('options');
        const toggleButton = document.getElementById('options-toggle');
        const logPanel = document.getElementById('log');
        
        if (optionsPanel.classList.contains('options-collapsed')) {
            optionsPanel.classList.remove('options-collapsed');
            logPanel.classList.remove('log-expanded');
            toggleButton.textContent = '▼';
            optionsPanel.style.height = '';
        } else {
            optionsPanel.classList.add('options-collapsed');
            logPanel.classList.add('log-expanded');
            toggleButton.textContent = '▶';
            optionsPanel.style.height = '25px'; // Show a sliver
        }
    }

    copyLog() {
        const logContent = document.getElementById('left-log-content');
        const text = logContent.innerText;
        
        navigator.clipboard.writeText(text).then(() => {
            const copyButton = document.getElementById('log-copy-button');
            const originalText = copyButton.textContent;
            copyButton.textContent = 'Copied!';
            setTimeout(() => {
                copyButton.textContent = originalText;
            }, 1000);
        }).catch(err => {
            console.error('Failed to copy log:', err);
        });
    }
    
    // New methods for density and labels
    
    extractUniqueLabels() {
        const labelSet = new Set();
        
        // Scan all pages for element types
        for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
            if (this.allStructureData[pageNum] && this.allStructureData[pageNum].page) {
                const page = this.allStructureData[pageNum].page;
                if (page.elements) {
                    page.elements.forEach(element => {
                        if (element.type) {
                            labelSet.add(element.type);
                        }
                    });
                }
            }
        }
        
        this.allLabels = Array.from(labelSet).sort();
        
        // Default: all labels active
        this.activeLabels = new Set(this.allLabels);
    }
    
    syncYDensityScroll() {
        const pdfScroller = document.getElementById('pdf-scroller');
        const yDensity = document.getElementById('y-density');
        
        if (!pdfScroller || !yDensity) return;
        
        let isSyncing = false;
        
        // Sync y-density scroll with pdf-scroller (one-way: pdf -> y-density)
        pdfScroller.addEventListener('scroll', () => {
            if (isSyncing) return;
            
            requestAnimationFrame(() => {
                const pdfMaxScroll = pdfScroller.scrollHeight - pdfScroller.clientHeight;
                const scrollPercent = pdfMaxScroll > 0 ? pdfScroller.scrollTop / pdfMaxScroll : 0;
                
                const yDensityMaxScroll = yDensity.scrollHeight - yDensity.clientHeight;
                if (yDensityMaxScroll > 0) {
                    isSyncing = true;
                    yDensity.scrollTop = scrollPercent * yDensityMaxScroll;
                    requestAnimationFrame(() => {
                        isSyncing = false;
                    });
                }
            });
        });
    }
    
    renderLabelToggles() {
        const container = document.getElementById('label-checkboxes');
        container.innerHTML = '';
        
        // Define colors for each label type
        const colorScheme = {
            'text': 'rgba(33, 150, 243, 0.3)',
            'title': 'rgba(76, 175, 80, 0.3)',
            'section_header': 'rgba(255, 152, 0, 0.3)',
            'table': 'rgba(244, 67, 54, 0.3)',
            'figure': 'rgba(156, 39, 176, 0.3)',
            'list_item': 'rgba(0, 188, 212, 0.3)',
            'default': 'rgba(158, 158, 158, 0.3)'
        };
        
        this.allLabels.forEach(label => {
            const item = document.createElement('div');
            item.className = 'label-checkbox-item';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `label-${label}`;
            checkbox.checked = this.activeLabels.has(label);
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    this.activeLabels.add(label);
                } else {
                    this.activeLabels.delete(label);
                }
                this.filterAnnotationsByLabels();
            });
            
            const labelEl = document.createElement('label');
            labelEl.htmlFor = checkbox.id;
            
            const swatch = document.createElement('span');
            swatch.className = 'label-color-swatch';
            swatch.style.backgroundColor = colorScheme[label] || colorScheme['default'];
            
            labelEl.appendChild(swatch);
            labelEl.appendChild(document.createTextNode(label));
            
            item.appendChild(checkbox);
            item.appendChild(labelEl);
            container.appendChild(item);
        });
    }
    
    selectAllLabels() {
        document.querySelectorAll('#label-checkboxes input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = true;
        });
        this.activeLabels = new Set(this.allLabels);
        this.filterAnnotationsByLabels();
    }
    
    deselectAllLabels() {
        document.querySelectorAll('#label-checkboxes input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = false;
        });
        this.activeLabels.clear();
        this.filterAnnotationsByLabels();
    }
    
    filterAnnotationsByLabels() {
        // Hide/show overlays, annotations, and lines based on active labels
        document.querySelectorAll('.annotation-overlay').forEach(overlay => {
            const elementType = overlay.dataset.elementType;
            if (!elementType || this.activeLabels.has(elementType)) {
                overlay.style.display = '';
            } else {
                overlay.style.display = 'none';
            }
        });
        
        document.querySelectorAll('.annotation-item').forEach(item => {
            const elementType = item.dataset.elementType;
            if (!elementType || this.activeLabels.has(elementType)) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
        
        document.querySelectorAll('.connection-line').forEach(line => {
            const elementType = line.dataset.elementType;
            if (!elementType || this.activeLabels.has(elementType)) {
                line.style.display = '';
            } else {
                line.style.display = 'none';
            }
        });
    }
    
    renderAllAnnotations() {
        // Render bounding boxes and annotations for all pages
        this.clearConnectionLines();
        
        for (let pageNum = 1; pageNum <= this.totalPages; pageNum++) {
            if (this.allStructureData[pageNum] && this.allStructureData[pageNum].page) {
                this.renderAnnotationsForPage(pageNum);
            }
        }
    }
    
    renderAnnotationsForPage(pageNum) {
        const structureData = this.allStructureData[pageNum];
        if (!structureData || !structureData.page) return;
        
        const page = structureData.page;
        const pageWrapper = document.querySelector(`.pdf-page-wrapper[data-page-num="${pageNum}"]`);
        
        if (!pageWrapper) return;
        
        // Create overlay container for this page if it doesn't exist
        let overlayContainer = pageWrapper.querySelector('.page-overlay-container');
        if (!overlayContainer) {
            overlayContainer = document.createElement('div');
            overlayContainer.className = 'page-overlay-container';
            overlayContainer.style.position = 'absolute';
            overlayContainer.style.top = '0';
            overlayContainer.style.left = '0';
            overlayContainer.style.width = '100%';
            overlayContainer.style.height = '100%';
            overlayContainer.style.pointerEvents = 'none';
            pageWrapper.style.position = 'relative';
            pageWrapper.appendChild(overlayContainer);
        }
        
        overlayContainer.innerHTML = '';
        
        const canvas = pageWrapper.querySelector('canvas');
        if (!canvas) return;
        
        const canvasRect = canvas.getBoundingClientRect();
        const scaleX = canvasRect.width / page.width;
        const scaleY = canvasRect.height / page.height;
        
        page.elements.forEach((element, index) => {
            if (!element.bbox || element.bbox.length !== 4) return;
            
            const [x0, y0, x1, y1] = element.bbox;
            
            // Create overlay element
            const overlay = document.createElement('div');
            overlay.className = 'annotation-overlay';
            overlay.style.position = 'absolute';
            overlay.style.left = `${x0 * scaleX}px`;
            overlay.style.top = `${y0 * scaleY}px`;
            overlay.style.width = `${(x1 - x0) * scaleX}px`;
            overlay.style.height = `${(y1 - y0) * scaleY}px`;
            overlay.dataset.page = pageNum;
            overlay.dataset.index = index;
            overlay.dataset.elementType = element.type || 'unknown';
            
            // Apply color based on type
            const color = this.getColorForType(element.type);
            overlay.style.borderColor = color.replace('0.3', '1');
            overlay.style.backgroundColor = color;
            
            overlay.addEventListener('click', () => this.selectAnnotation(index, pageNum));
            
            overlayContainer.appendChild(overlay);
        });
    }
    
    getColorForType(type) {
        const colorScheme = {
            'text': 'rgba(33, 150, 243, 0.3)',
            'title': 'rgba(76, 175, 80, 0.3)',
            'section_header': 'rgba(255, 152, 0, 0.3)',
            'table': 'rgba(244, 67, 54, 0.3)',
            'figure': 'rgba(156, 39, 176, 0.3)',
            'list_item': 'rgba(0, 188, 212, 0.3)',
        };
        return colorScheme[type] || 'rgba(158, 158, 158, 0.3)';
    }
    
    // All density chart methods moved to density-charts.js module
}

// Initialize the viewer when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new Johnny5Viewer();
});
</file>

<file path="src/johnny5/web/static/density-charts.js">
// Johnny5 Density Charts Module

/**
 * Manages rendering and scrolling of density charts for the web viewer
 */
class DensityCharts {
    constructor(viewer) {
        this.viewer = viewer;
        this.isSyncing = false;
    }

    syncYDensityScroll() {
        const pdfScroller = document.getElementById('pdf-scroller');
        const yDensity = document.getElementById('y-density');
        const xDensity = document.getElementById('x-density');
        
        if (!pdfScroller || !yDensity) return;
        
        let isSyncing = false;
        
        // Sync y-density scroll with pdf-scroller (one-way: pdf -> y-density)
        pdfScroller.addEventListener('scroll', () => {
            if (isSyncing) return;
            
            requestAnimationFrame(() => {
                // Since renderYDensityChart sets the canvas height to match the
                // total PDF scrollHeight, we can just map the scrollTop directly.
                isSyncing = true;
                yDensity.scrollTop = pdfScroller.scrollTop;
                
                // Sync horizontal scroll of x-density with pdf-scroller
                if (xDensity) {
                    xDensity.scrollLeft = pdfScroller.scrollLeft;
                }
                
                requestAnimationFrame(() => {
                    isSyncing = false;
                });
            });
        });
    }


    renderXDensityChart(densityData) {
        const canvas = document.getElementById('x-density-chart');
        if (!canvas) return;
        
        // Get the actual width of the current page's canvas
        const pageNum = this.viewer.currentPage;
        const pageWrapper = document.querySelector(`.pdf-page-wrapper[data-page-num="${pageNum}"]`);
        if (!pageWrapper) return;
        
        const pageCanvas = pageWrapper.querySelector('canvas');
        if (!pageCanvas) return;
        
        const actualPageWidth = parseFloat(pageCanvas.style.width);
        
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio;
        
        canvas.width = actualPageWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        
        const data = densityData.x;
        if (!data || data.length === 0) return;
        
        const maxValue = Math.max(...data);
        const barWidth = actualPageWidth / data.length;
        
        ctx.clearRect(0, 0, actualPageWidth, canvas.offsetHeight);
        ctx.fillStyle = '#4CAF50';
        
        data.forEach((value, index) => {
            const barHeight = (value / maxValue) * canvas.offsetHeight;
            const x = index * barWidth;
            const y = canvas.offsetHeight - barHeight;
            
            ctx.fillRect(x, y, barWidth, barHeight);
        });
        
        canvas.style.width = actualPageWidth + 'px';
    }

    renderXDensityRightChart(densityData) {
        const canvas = document.getElementById('x-density-right-chart');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        
        canvas.width = canvas.offsetWidth * window.devicePixelRatio;
        canvas.height = canvas.offsetHeight * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        
        const data = densityData.x;
        if (!data || data.length === 0) return;
        
        const maxValue = Math.max(...data);
        const barWidth = canvas.offsetWidth / data.length;
        
        ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
        ctx.fillStyle = '#4CAF50';
        
        data.forEach((value, index) => {
            const barHeight = (value / maxValue) * canvas.offsetHeight;
            const x = index * barWidth;
            const y = canvas.offsetHeight - barHeight;
            
            ctx.fillRect(x, y, barWidth, barHeight);
        });
    }


    /**
     * Renders charts that update as the current page changes (X-axes).
     */
    updateDynamicCharts() {
        const pageNum = this.viewer.currentPage;
        const densityData = this.viewer.allDensityData[pageNum];
        
        if (!densityData) return;
        
        this.renderXDensityChart(densityData);
        this.renderXDensityRightChart(densityData);
    }

    /**
     * Renders charts that are static and match the full document (Y-axes).
     * This version CALCULATES height instead of reading it, avoiding race conditions.
     */
    async renderStaticCharts() {
        const yDensityScroller = document.getElementById('y-density');
        const yDensityRight = document.getElementById('y-density-right');
        
        if (!yDensityScroller || !yDensityRight || !this.viewer.pdfDoc) return;

        // Clear any old canvases
        yDensityScroller.innerHTML = '';
        yDensityRight.innerHTML = '';
        
        const pageWrappers = document.querySelectorAll('.pdf-page-wrapper');
        if (pageWrappers.length === 0) return;

        // Find the global max value for scaling *all* charts consistently
        let globalMaxValue = 0;
        pageWrappers.forEach(wrapper => {
            const pageNum = parseInt(wrapper.dataset.pageNum, 10);
            const pageData = this.viewer.allDensityData[pageNum];
            if (pageData && pageData.y && Array.isArray(pageData.y)) {
                const pageMax = Math.max(...pageData.y);
                if (pageMax > globalMaxValue) {
                    globalMaxValue = pageMax;
                }
            }
        });

        if (globalMaxValue === 0) return; // No data

        // Wait for PDF to fully render and get actual scrollHeight
        const pdfScroller = document.getElementById('pdf-scroller');
        await new Promise(resolve => requestAnimationFrame(() => resolve()));
        
        // Get the ACTUAL scrollable height from the PDF scroller
        const totalPdfHeight = pdfScroller.scrollHeight;
        const parentWidth = yDensityScroller.offsetWidth;
        
        if (totalPdfHeight <= 0 || parentWidth <= 0) return;
        
        console.log(`[renderStaticCharts] PDF scrollHeight=${totalPdfHeight}, parentWidth=${parentWidth}`);
        
        // --- Create SINGLE LEFT Y-Density Canvas for entire document ---
        const canvas = document.createElement('canvas');
        canvas.style.width = '100%';
        canvas.style.height = `${totalPdfHeight}px`;
        yDensityScroller.appendChild(canvas);
        
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio;
        canvas.width = parentWidth * dpr;
        canvas.height = totalPdfHeight * dpr;
        ctx.scale(dpr, dpr);
        
        // Draw density bars and page breaks by accumulating actual heights
        let currentY = 0;
        for (let i = 0; i < pageWrappers.length; i++) {
            const wrapper = pageWrappers[i];
            const pageNum = parseInt(wrapper.dataset.pageNum, 10);
            const pageData = this.viewer.allDensityData[pageNum];
            const data = (pageData && pageData.y) ? pageData.y : [];
            
            // Get ACTUAL page height from the DOM
            const actualPageHeight = wrapper.offsetHeight;
            
            if (data.length > 0 && actualPageHeight > 0) {
                const barHeight = actualPageHeight / data.length;
                ctx.fillStyle = '#4CAF50';
                
                data.forEach((value, index) => {
                    const barWidth = (value / globalMaxValue) * parentWidth;
                    ctx.fillRect(parentWidth - barWidth, currentY + (index * barHeight), barWidth, barHeight);
                });
            }
            
            // Draw page break line (except after last page)
            if (i < pageWrappers.length - 1) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, currentY + actualPageHeight);
                ctx.lineTo(parentWidth, currentY + actualPageHeight);
                ctx.stroke();
            }
            
            currentY += actualPageHeight;
        }
        // Draw verification grid over the left Y-density canvas (align with PDF grid)
        this.drawHorizontalGrid(ctx, parentWidth, totalPdfHeight, (window.__GRID_STEP_PX || 50));
        
        // --- Create SINGLE RIGHT Y-Density Canvas for entire document ---
        const rightCanvas = document.createElement('canvas');
        rightCanvas.style.width = '100%';
        rightCanvas.style.height = `${totalPdfHeight}px`;
        yDensityRight.appendChild(rightCanvas);
        
        const rightCtx = rightCanvas.getContext('2d');
        rightCanvas.width = parentWidth * dpr;
        rightCanvas.height = totalPdfHeight * dpr;
        rightCtx.scale(dpr, dpr);
        
        // Draw for right canvas
        currentY = 0;
        for (let i = 0; i < pageWrappers.length; i++) {
            const wrapper = pageWrappers[i];
            const pageNum = parseInt(wrapper.dataset.pageNum, 10);
            const pageData = this.viewer.allDensityData[pageNum];
            const data = (pageData && pageData.y) ? pageData.y : [];
            
            const actualPageHeight = wrapper.offsetHeight;
            
            if (data.length > 0 && actualPageHeight > 0) {
                const barHeight = actualPageHeight / data.length;
                rightCtx.fillStyle = '#2196F3';
                
                data.forEach((value, index) => {
                    const barWidth = (value / globalMaxValue) * parentWidth;
                    rightCtx.fillRect(parentWidth - barWidth, currentY + (index * barHeight), barWidth, barHeight);
                });
            }
            
            currentY += actualPageHeight;
        }
        // Draw verification grid over the right Y-density canvas (align with PDF grid)
        this.drawHorizontalGrid(rightCtx, parentWidth, totalPdfHeight, (window.__GRID_STEP_PX || 50));
    }

    /**
     * Helper function to render density data onto a specific canvas for a single page.
     */
    renderPageDensityChart(canvas, data, globalMaxValue, pageHeight, color) {
        const parentWidth = canvas.parentElement.offsetWidth;
        if (parentWidth <= 0 || pageHeight <= 0) return;

        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio;

        canvas.width = parentWidth * dpr;
        canvas.height = pageHeight * dpr;
        ctx.scale(dpr, dpr);

        ctx.clearRect(0, 0, parentWidth, pageHeight);
        
        if (!data || data.length === 0) return;
        
        ctx.fillStyle = color;
        const barHeight = pageHeight / data.length;

        data.forEach((value, index) => {
            const barWidth = (value / globalMaxValue) * parentWidth;
            const x = parentWidth - barWidth;
            const y = index * barHeight;
            
            ctx.fillRect(x, y, barWidth, barHeight);
        });
    }

    /**
     * Draws a horizontal grid every fixed pixel interval to visually verify
     * scroll synchronization with the PDF scroller. Uses device-pixel crisp lines.
     */
    drawHorizontalGrid(ctx, width, height, step) {
        const gridStep = step > 0 ? step : 50; // px
        const pdfContainer = document.getElementById('pdf-canvas-container');
        const style = pdfContainer ? window.getComputedStyle(pdfContainer) : null;
        const padTop = style ? (parseFloat(style.paddingTop) || 0) : 0;
        const yStart = (gridStep - (padTop % gridStep)) % gridStep;
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1;
        // 0.5px offset for crisp 1px lines
        for (let y = yStart; y <= height; y += gridStep) {
            ctx.beginPath();
            ctx.moveTo(0, Math.floor(y) + 0.5);
            ctx.lineTo(width, Math.floor(y) + 0.5);
            ctx.stroke();
        }
        ctx.restore();
    }
}
</file>

<file path="README.md">
# Johnny5 — Document Disassembly and Reassembly Framework

**Johnny5** is a modular Python package for understanding and reconstructing complex documents.

> **⚠️ Alpha Software**: This is early-stage software. Expect breaking changes and rough edges.

1. **Disassembles** PDFs into Docling's lossless JSON representation.
2. Applies a user-defined, hot-reloadable **fixup** layer for structural corrections.
3. **Extracts** data hidden in structure to a content-only JSON of the user's preference.
4. Reconstructs rich formats such as QMD.
5. Serves an interactive FastAPI web interface (powered by PDF.js) to visualize and debug the process.

---

## 🚀 Installation

```bash
git clone https://github.com/wawiesel/johnny5.git
cd johnny5
pip install -e .
```

---

## 🧰 Quick Start

```bash
jny5 view examples/x/sample.pdf
# starts web server and renders left pane deconstruction only
```

```bash
cd examples/x
jny5 view sample.pdf --fixup fixup.py --extract extract.py --reconstruct reconstruct.py
# renders full reconstruction pipeline
```
 
Visit `http://localhost:8000` to explore the PDF structure visually.

---

## 🧠 Features

* Accurate PDF → JSON conversion using **Docling**
* Intelligent region & margin detection
* Hot-reloading fixup scripts
* QMD/HTML reconstruction
* Web-based visual comparison of source and reconstructed layouts

---

## 🤝 Contributing

See [CONTRIBUTING.md](CONTRIBUTING.md).

---

## 📜 License

MIT License © 2025 William Wieselquist
</file>

</files>
