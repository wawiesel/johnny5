From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Assistant <assistant@example.com>
Date: Wed, 29 Oct 2025 00:00:00 +0000
Subject: [PATCH] Fix grid/ruler Y offset: align to page bottom by scroller-relative math

- Stop double-counting container padding.
- Compute per-page offsets in scroller coordinates using getBoundingClientRect().
- Align X-axis to exact PDF bottom and left-panel ruler to grid.
- No behavior change to zoom or rendering order.

---
 1 file changed, 24 insertions(+), 14 deletions(-)
--- a/src/johnny5/web/static/app.js
+++ b/src/johnny5/web/static/app.js
@@ -1,6 +1,7 @@
     async drawPdfGrid() {
         const scroller = document.getElementById('pdf-scroller');
         const container = document.getElementById('pdf-canvas-container');
         if (!scroller || !container || !this.pdfDoc) return;

-        const padTop = parseFloat(getComputedStyle(container).paddingTop) || 0;
-        const padLeft = parseFloat(getComputedStyle(container).paddingLeft) || 0;
+        // Work entirely in scroller coordinates
+        const scrollerRect = scroller.getBoundingClientRect();

         const pageWrappers = container.querySelectorAll('.pdf-page-wrapper');
         const pdfStep = 15;
@@ -11,9 +12,12 @@
             const pageNum = +wrapper.dataset.pageNum;
             const pageTop = wrapper.offsetTop;
             const page = await this.pdfDoc.getPage(pageNum);
             const viewport = page.getViewport({ scale: this.scale });

-            const offsetX = padLeft;
-            const offsetY = padTop + pageTop;
+            // Offsets to the pageâ€™s top-left in scroller space
+            const wrapperRect = wrapper.getBoundingClientRect();
+            const offsetX = (wrapperRect.left - scrollerRect.left) + scroller.scrollLeft;
+            const offsetY = (wrapperRect.top  - scrollerRect.top)  + scroller.scrollTop;

             // PDF-space bounds
             const [pageWidth, pageHeight] = page.view.slice(2);
@@ -23,14 +27,14 @@
             const [x2, y2] = viewport.convertToViewportPoint(0, pageHeight);

             // X-axis at PDF y=0 (bottom)
-            const yOrigin = offsetY + viewport.height;
+            const yOrigin = offsetY + viewport.height;
             ctx.beginPath();
             ctx.moveTo(offsetX + x0, yOrigin);
             ctx.lineTo(offsetX + x1, yOrigin);
             ctx.strokeStyle = 'rgba(220,0,0,0.9)';
             ctx.lineWidth = 1.5;
             ctx.stroke();

             // Y-axis at PDF x=0
-            const yTop = offsetY + (viewport.height - y2);
+            const yTop = offsetY + (viewport.height - y2);
             ctx.beginPath();
             ctx.moveTo(offsetX + x0, yOrigin);
             ctx.lineTo(offsetX + x2, yTop);
@@ -42,12 +46,12 @@
             ctx.beginPath();
             ctx.moveTo(offsetX + x0, offsetY + y0);
             ctx.lineTo(offsetX + xStep, offsetY + yStep);
             ctx.stroke();

             // horizontal lines at constant PDF y
             ctx.strokeStyle = 'rgba(0,0,0,0.1)';
             ctx.lineWidth = 0.5;
             for (let yPdf = 0; yPdf <= pageHeight; yPdf += pdfStep) {
                 if (yPdf === 0) continue; // already drew the X-axis
                 const [xH0, yLocal] = viewport.convertToViewportPoint(0, yPdf);
                 const [xH1] = viewport.convertToViewportPoint(pageWidth, yPdf);
-                const yGlobal = offsetY + (viewport.height - yLocal);
+                const yGlobal = offsetY + (viewport.height - yLocal);
                 const sx0 = Math.floor(offsetX + xH0) + 0.5;
                 const sy0 = Math.floor(yGlobal) + 0.5;
                 const sx1 = Math.floor(offsetX + xH1) + 0.5;
                 ctx.beginPath();
                 ctx.moveTo(sx0, sy0);
@@ -58,10 +62,10 @@
             for (let xPdf = 0; xPdf <= pageWidth; xPdf += pdfStep) {
                 if (xPdf === 0) continue; // already drew the Y-axis
                 const [xLocal0, yLocal0] = viewport.convertToViewportPoint(xPdf, 0);
                 const [xLocal1, yLocal1] = viewport.convertToViewportPoint(xPdf, pageHeight);
-                const xGlobal = Math.floor(offsetX + xLocal0) + 0.5;
-                const yBottom = Math.floor(offsetY + viewport.height - yLocal0) + 0.5;
-                const yTopV   = Math.floor(offsetY + viewport.height - yLocal1) + 0.5;
+                const xGlobal = Math.floor(offsetX + xLocal0) + 0.5;
+                const yBottom = Math.floor(offsetY + viewport.height - yLocal0) + 0.5;
+                const yTopV   = Math.floor(offsetY + viewport.height - yLocal1) + 0.5;
                 ctx.beginPath();
                 ctx.moveTo(xGlobal, yBottom);
                 ctx.lineTo(xGlobal, yTopV);
                 ctx.stroke();
             }
         }
     }

     async drawLeftPanelRuler() {
         const yPanel   = document.getElementById('y-density');
         const scroller = document.getElementById('pdf-scroller');
         const container = document.getElementById('pdf-canvas-container');
         if (!yPanel || !scroller || !container || !this.pdfDoc) return;

         yPanel.style.height = scroller.clientHeight + 'px';
-        const totalHeight = container.scrollHeight;
+        const totalHeight = container.scrollHeight;

         yPanel.innerHTML = '';
         const canvas = document.createElement('canvas');
         yPanel.appendChild(canvas);
         const panelWidth = Math.max(36, yPanel.clientWidth || 36);
         const dpr = window.devicePixelRatio || 1;

         canvas.style.width  = `${panelWidth}px`;
         canvas.style.height = `${totalHeight}px`;
         canvas.width  = Math.floor(panelWidth * dpr);
         canvas.height = Math.floor(totalHeight * dpr);

         const ctx = canvas.getContext('2d');
         ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
         ctx.clearRect(0, 0, panelWidth, totalHeight);

         const pdfStep = 15;
-        const padTop = parseFloat(getComputedStyle(container).paddingTop) || 0;
+        const scrollerRect = scroller.getBoundingClientRect();

         ctx.strokeStyle = 'rgba(0,0,0,0.35)';
         ctx.lineWidth = 1;

         const pages = container.querySelectorAll('.pdf-page-wrapper');
         for (const wrapper of pages) {
             const pageNum = +wrapper.dataset.pageNum;
-            const pageTop = wrapper.offsetTop;
             const page = await this.pdfDoc.getPage(pageNum);
             const viewport = page.getViewport({ scale: this.scale });
             const [, , x1, y1] = page.view;
             const pageHeight = (y1);

             for (let yPdf = 0; yPdf <= pageHeight + 1e-6; yPdf += pdfStep) {
-                const [, yLocal] = viewport.convertToViewportPoint(0, yPdf);
-                const y = padTop + pageTop + yLocal;
+                const [, yLocal] = viewport.convertToViewportPoint(0, yPdf);
+                const wrapperRect = wrapper.getBoundingClientRect();
+                const base = (wrapperRect.top - scrollerRect.top) + scroller.scrollTop;
+                const y = base + yLocal;
                 const yPx = Math.floor(y) + 0.5;
                 ctx.beginPath();
                 ctx.moveTo(0, yPx);
                 ctx.lineTo(panelWidth, yPx);
                 ctx.stroke();
             }
         }

         if (!this._rulerScrollHandler) {
             this._rulerScrollHandler = () => { yPanel.scrollTop = scroller.scrollTop; };
             scroller.addEventListener('scroll', this._rulerScrollHandler);
         }
         yPanel.scrollTop = scroller.scrollTop;
     }
--
2.34.1
